<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[总结微信小程序开发中遇到的坑]]></title>
    <url>%2F2017%2F09%2F01%2Fwxapp%2F</url>
    <content type="text"><![CDATA[总结微信小程序开发中遇到的坑,一些坑你得一个一个的跳啊,/(ㄒoㄒ)/~~ 1,页面跳转和参数传递实例 首先说一下我遇到的需求有一个我的消息页面,里面的数据都是后端返回的,返回的数据大致如下,有一个是数据url是要控制跳转到哪个页面,可能是tab页面也可能是非tab页面,但是微信小程序中跳转到tab和非tab页面用的api不是同一个,但是在页面中渲染肯定是要用到循环的,难道要再多个参数来判断是跳转到tab页面还是非tab页面? 1234567891011121314151617[ &#123; "id": 2121, "title": "test", "body": "test", "url": "url", "pic": "pic", "created_at": "2017-07-01 12:34:56" &#125;, &#123; "id": 2122, "title": "test", "body": "test", "url": "url", "pic": "pic", "created_at": "2017-07-01 12:34:56" &#125;,] 后一般的小程序中我用的框架是wepy,底部的tab组件就是我自己写的,没有用到小程序自己提供的那一个,因为我们还要实现一个需求,有消息时,底部tab会出现小红点,还有以下弹窗要把底部tab覆盖掉,这些需求如果用小程序提供的那一个tab组件的话根本实现不了;而且不用wepy框架的话,自己做一个tab实现的过程很恶心,小程序虽然实现了组件化,但是它实现的组件化bong不想vue和react那样实现的是真正的组件化,你需要哪个组件就直接import进来,小程序的组件化实现可查看官方文档,js,css和html都是要分别引入的 自己实现的tab页面整体是一个非tab页面,所有整个小程序中就不存在绝对的tab页面,所以用navigator这个组件,想要跳转到tab页面可以通过在url上拼接参数 123456&lt;view class="mesList" wx:for="&#123;&#123;unReadList&#125;&#125;" wx:key="unique"&gt; &lt;navigator url="/pages/index?tab=0" hover-class="none" &gt; &lt;text&gt;&#123;&#123;item.body&#125;&#125;&lt;/text&gt; &lt;view class="messageTime"&gt;&#123;&#123;item.created_at&#125;&#125;&lt;/view&gt; &lt;/navigator&gt;&lt;/view&gt; 然后再index页面的onload中判断显示哪个tab123456onLoad(options) &#123; if (options &amp;&amp; options.tab) &#123; this.tab = parseInt(options.tab); this.$apply(); &#125;&#125; 2,微信小程序授权处理 微信小程序提示授权弹窗,如果用户第一次点击拒绝之后,一段时间将不会再次弹出来,然后用户又不知道什么原因用不了小程序,这是个很糟糕的用户体验,我们应该优雅的处理这种情况 采用的解决方法参考 3, 登录问题的处理 两个登录接口,一个get,判断是否已经还需要登录,如果返回true,则需要登录,如果返回false,则不需要登录 如果返回true,则需要去请求更一个post的登录接口,这时,你需要获取第一个get请求的返回信息中的session,之后每次请求求都需要带上他 在返回true的时候还需要做一件事儿,就是把返回信息中的session存储到storage,即调用setStorage,然后在之后每次请求数据的时候在headers里加上这个字段1234567891011121314151617181920212223242526272829function getStorage(key) &#123; return new Promise(function (resolve, reject) &#123; // 先判断本地数据存储有没有cookie wx.getStorage(&#123; key: key, success: function (res) &#123; resolve(res.data); &#125;, fail: function (res) &#123; resolve(null); &#125;, &#125;); &#125;);&#125;function setStorage(key, value) &#123; return new Promise(function (resolve, reject) &#123; wx.setStorage(&#123; key: key, data: value, success: function (res) &#123; // TODO: 不知道返回什么 resolve(res.data); &#125;, fail: function (res) &#123; reject(res.errMsg); &#125;, &#125;); &#125;);&#125; 4,wx.getStorage安卓手机上返回的错误信息是getStorage:fail,ios,getStorage:fail data not found 在判断一些api返回的错误信息时,最好不要通过判断具体的错误信息来处理错误12345678910111213141516171819202122function getStorage(key) &#123; return new Promise(function (resolve, reject) &#123; // 先判断本地数据存储有没有cookie wx.getStorage(&#123; key: key, success: function (res) &#123; resolve(res.data); &#125;, fail: function (res) &#123; resolve(null); // 下面注释的部分即为刚开始犯的错误,导致有可能ios或安卓或部分机型显示不出数据 // if (res.errMsg == 'getStorage:fail' || res.errMsg == 'getStorage:fail data not found') &#123; // console.log('没有cookie'); // resolve(null); // &#125; else &#123; // console.log('这是一个问题'); // reject(res.errMsg); // &#125; &#125;, &#125;); &#125;);&#125; 5,小程序解决异步 如果项目中没有用到babal,小程序本身的支持只支持到es6的语法,所以解决异步的问题就不能使用es7的async和await,只能使用promise来解决异步,但是每个api上都进行一次封装(如下),这种做法太恶心了 123456789101112function login() &#123; return new Promise(function (resolve, reject) &#123; wx.login(&#123; success: function (res) &#123; resolve(res); &#125;, fail: function (res) &#123; reject(res.errMsg); &#125;, &#125;); &#125;);&#125; 基于微信的API的prototype上进行了promise的封装 123456789101112131415function promiseify(func) &#123; return (args = &#123;&#125;) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; func.call(wx, Object.assign(args, &#123; success: resolve, fail: reject, &#125;)); &#125;) &#125;&#125;for (const key in wx) &#123; if (Object.prototype.hasOwnProperty.call(wx, key) &amp;&amp; typeof wx[key] === 'function') &#123; wx[`_$&#123;key&#125;`] = promiseify(wx[key]); &#125;&#125; 6,怎么保证在调用其他接口之前已经调用过登录的接口了 我采用执行队列的方式来解决,问题可以简化为有两个按钮,点击第一个按钮输出这是第几次输出d1,但是必须在点击完d2之后,isPrint变为true时,才允许输出,在isPrint为false的时候点击d1,需要把要输出的内容暂时存储起来,等isPrint变为true时,暂存起来的输出现在才可以输出出来12345678910111213141516171819202122232425262728293031323334// html &lt;div class="first"&gt;按钮一&lt;/div&gt; &lt;div class="second"&gt;按钮二&lt;/div&gt;// js const d1 = document.querySelector('.first'); const d2 = document.querySelector('.second'); let count = 0; // 用来记录第几次输出 let isPrint = false; // 是否允许输出 let arr = []; // 声明一个数组,用来存储 function clickCount() &#123; count++; console.log('这是第' + count + '次输出d1'); &#125; d1.onclick = function () &#123; console.log(isPrint); console.log(arr); if (isPrint) &#123; if (arr.length === 0) &#123; clickCount(); &#125; else &#123; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; arr[i](); &#125; &#125; &#125; else &#123; arr.push(clickCount); console.log('不允许输出'); &#125; &#125;; d2.onclick = function () &#123; isPrint = true; console.log(isPrint); &#125; 6,小程序问题 不支持跳转外部链接 text可以解析/n, 目前不支持识别图中二维码， 背景图片不能用本地图片， wx.navigateTo需要跳转的应用内非 tabBar 的页面的路径 wx.switchTab跳转到tabBar页面， wx.showToast(),icon只支持success和loading,但是支持image,且image优先级高于icon tabBar页面A navigatorTo 到页面B，然后B switchTab 到A，这里A会执行onShow()；但是我再从A跳到B再switchTab回来，A就不会再执行onShow()了， 7,总结 有时候在开发者工具上测试时是没有问题的,但是真机测试却有问题,所有开发过程中一定要在多个不同型号的手机上测试;很多时候IOS和安卓api返回的信息不同 在手机上打开调试的时候是好的,但是关闭调试后就会出现各种bug,遇到这种情况一定要一步步的去排查原因 8,后采用wepy重构小程序遇到的一些坑wepy文档1，Q: 怎么在page组件和component组件中回去到getApp(),就是app里面定义的函数,通过this.$parent只能拿到数据，拿不到方法?A:可以在this.$parent的_proto上拿到方法,即this.$parent.onLogin2, Q:怎么实现按需加载A:在compoent组件中自定义生命周期函数,并手动触发]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue生命周期详解]]></title>
    <url>%2F2017%2F08%2F29%2Fvue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[vue声明周期,在每个声明周期中都干了些什么? 1, vue的生命周期 beforeCreate: 组件实例刚刚被创建,组件属性计算之前,如data属性 created: 组件实例创建完成,属性已绑定,但是DOM还未完成,$el属性还不存在 beforeMount:模板编译/挂载之前 mounted: 模板编译/挂载之后 beforeUpdate: 组件更新之前 updated: 组件更新之后 activated: for keep-alive,组件被激活时调用 deactivated: for keep-alive,组件被移除时调用 beforeDestroy: 组件销毁前被调用 destoryed: 组件销毁后调用 ps:下面代码可以直接复制出去执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;script type="text/javascript" src="https://cdn.jsdelivr.net/vue/2.1.3/vue.js"&gt;&lt;/script&gt;&lt;body&gt; &lt;div id="app"&gt;&#123;&#123;a&#125;&#125;&lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; a: 'vuejs', &#125;, beforeCreate: function() &#123; console.log('创建前'); console.log(this.a); console.log(this.$el); &#125;, created: function() &#123; console.log('创建之后'); console.log(this.a); console.log(this.$el); &#125;, beforeMount: function() &#123; console.log('mount之前'); console.log(this.a); console.log(this.$el); &#125;, mounted: function() &#123; console.log('mount之后'); console.log(this.a); console.log(this.$el); &#125;, beforeUpdate: function() &#123; console.log('更新之前'); console.log(this.a); console.log(this.$el); &#125;, updated: function() &#123; console.log('更新完成'); console.log(this.a); console.log(this.$el); &#125;, beforeDestroy: function() &#123; console.log('组件销毁之前'); console.log(this.a); console.log(this.$el); &#125;, destroyed: function() &#123; console.log('组件销毁之后'); console.log(this.a); console.log(this.$el); &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; beforeCreated: el和data并未初始化created: 完成data数据的初始化,el没有beforeMount: 完成了el和data初始化mounted: 完成挂载1vm.a = &apos;change&apos;;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件通信]]></title>
    <url>%2F2017%2F08%2F29%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[组件通信是很重要的一部分,父组件怎么传数据给子组件,子组件怎么传递数据给父组件? 1,父组件给子组件传递数据 vue中使用props向子组件传递数据1): 子组件在props中创建一个属性,用于接收父组件传过来的值2): 父组件中注册子组件3): 在子组件标签中添加子组件props中创建的属性4): 把需要传给子组件的值赋给该属性 2,子组件向父组件传递数据子组件主要通过事件传递数据给父组件1), 子组件中需要以某种方式,例如点击事件的方法来触发一个自定义事件2),将需要传的值作为$emit的第二个参数,该值将作为实参数传给相应自定义事件的方法3),在父组件中注册子组件并在子组件标签上绑定自定义事件的监听 3,子组件向子组件传递数据vue找那个没有直接子组件对子组件传参的方法,建议将需要传递数据的在组件,都合并为一个组件,如果一定需要子组件对子组件传参,可以先传到父组件,再传到子组件,为了方便开发,vue推出了一个状态管理工具vuex,可以啃方便的实现组件之间的参数传递 具体的实例代码如下:可以自行参考相关代码在编辑器中尝试 父组件向子组件传递数据 123456789101112131415161718192021222324252627282930313233// 父组件向子组件传递数据&lt;!--msg 是在data中(父组件)定义的变量如果需要从父组件中获取logo的值,就需要使用props['msg'], 如30行在props中添加了元素以后,就不需要在data中(子组件)中再添加变量了--&gt;&lt;template&gt; &lt;div&gt; &lt;child @transferuser="getUser" :msg="msg"&gt;&lt;/child&gt; &lt;p&gt;用户名为:&#123;&#123;user&#125;&#125;(我是子组件传递给父组件的数据)&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import child from './child.vue'; export default &#123; components: &#123; child, &#125;, data() &#123; return &#123; user: '', msg: '我是父组件传给子组件的信息', &#125;; &#125;, methods: &#123; getUser(msg) &#123; this.user = msg; console.log(msg); &#125;, &#125;, &#125;;&lt;/script&gt; 子组件向父组件传递数据 12345678910111213141516171819202122232425262728293031323334// 子组件向父组件传递数据&lt;!--1.@ : 是 v-on的简写2.子组件主要通过事件传递数据给父组件3.当input的值发生变化时,将username传递给parent.vue,首先声明了一个setUser,用change事件来调用setUser4.在setUser中,使用了$emit来遍历transferUser事件,并返回this.username,其中transferuser是一个自定义事件,功能类似一个中转,this.username通过这个事件传递给父组件--&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;span&gt;用户名&lt;/span&gt; &lt;input v-model="username" @change='setUser'&gt;向父组件传值&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; username: '测试', &#125;; &#125;, props: &#123; msg: &#123; type: String, &#125;, &#125;, methods: &#123; setUser() &#123; this.$emit('transferuser', this.username); &#125;, &#125;, &#125;;&lt;/script&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的函数节流]]></title>
    <url>%2F2017%2F08%2F27%2Fjs%E7%9A%84%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[什么是函数节流?为什么要用到函数节流?函数节流可以解决哪写问题? 函数节流 使用场景: (1)对于常见的场景，如网页滚动时，经常会有滚动到哪时做什么样的动画效果，遂要注册onscroll事件，如何减少触发次数，到达优化性能，同时又满足效果要求不卡顿，一个是优化事件内代码，减少代码量，二就是做函数节流。 (2)在前端开发中，有时会为页面绑定resize事件，或者为一个页面元素绑定拖拽事件（其核心就是绑定mousemove），这种事件有一个特点，就是用户不必特地捣乱，他在一个正常的操作中，都有可能在一个短的时间内触发非常多次事件绑定程序。而大家知道，DOM操作时很消耗性能的，这个时候，如果你为这些事件绑定一些操作DOM节点的操作的话，那就会引发大量的计算，在用户看来，页面可能就一时间没有响应，这个页面一下子变卡了变慢了。甚至在IE下，如果你绑定的resize事件进行较多DOM操作，其高频率可能直接就使得浏览器崩溃。原理 定时器，当触发一个事件时，先setTimeout让这个事件延迟一会再执行，如果在这个时间间隔内又触发了事件，那我们就clear掉原来的定时器，再setTimeout一个新的定时器延迟一会执行 123456789function throttle(method, context) &#123; clearTimeout(method, tId); method.tId = setTimeout(function()&#123; method.call(context); &#125;)&#125;window.onresize = function() &#123; throttle(myFunc);&#125; 1234567891011var throttle = function(fn, delay) &#123; var timer = null; return function() &#123; var context = this, args = arguments; clearTimeout(timer); timer = setTimeout(function() &#123; fn.apply(context, args); &#125;, delay); &#125;&#125;window.onresize = throttle(myFunc, 100); 12345678910111213141516171819var throttleV2 = function (fn, delay, mustRunDelay) &#123; var timer = null; var t_start; return function() &#123; var context = this, args = arguments, t_curr = +new Date(); clearTimeout(timer); if(!t_start) &#123; t_start = t_curr; &#125; if(t_curr - t_start &gt;= mustRunDelay) &#123; fn.apply(context, args); &#125; else &#123; timer = setTimeout(function() &#123; fn.apply(context, args); &#125;, delay); &#125; &#125;&#125;window.onresize = throttleV2(myFunc, 50, 100);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js垃圾回收机制]]></title>
    <url>%2F2017%2F08%2F27%2Fjs%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[你了解javascript的垃圾回收机制么? 引用计数此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。 标记清除当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。 垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嘿,使用vue,你注意到了这些了么?]]></title>
    <url>%2F2017%2F08%2F23%2Fvue%E4%B8%AD%E6%A3%80%E6%B5%8B%E4%B8%8D%E5%88%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[使用vue过程中,遇到了一些问题,这里先总结以下两个: 问题一:vue组件之间传递数据,在子组件中我想改变一个从父组件中传过来的值 这是父组件1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;Child :message="message"&gt;&lt;/Child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from './child.vue';export default &#123; data() &#123; return &#123; message: '这是传给子组件的信息', &#125;; &#125;, components: &#123; Child, &#125;,&#125;;&lt;/script&gt; 这是子组件123456789101112131415161718192021&lt;template&gt; &lt;div @click="handleChange"&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; message: &#123; type: String, default: '这是默认信息', &#125;, &#125;, methods: &#123; handleChange() &#123; this.message = '我是子组件修改后的信息'; &#125;, &#125;, &#125;;&lt;/script&gt; 如果你这样写就会报一下错误但是在子组件中，我们不要去修改 prop。如果你必须要修改到这些数据，你可以使用以下方法： 把 prop 赋值给一个局部变量，然后需要修改的话就修改这个局部变量，而不影响 prop1234567891011121314151617181920212223242526&lt;template&gt; &lt;div @click="handleChange"&gt; &#123;&#123;newMessage&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; message: &#123; type: String, default: '这是默认信息', &#125;, &#125;, data() &#123; return &#123; newMessage: this.message, &#125;; &#125;, methods: &#123; handleChange() &#123; this.newMessage = '我是子组件修改后的信息'; &#125;, &#125;, &#125;;&lt;/script&gt; 问题二:vue中检测不到data的变化,我想把给data中的a赋值一个新的对象(添加一个它本身不存在的属性),然而经过尝试发现直接赋值是行不通的,以下是我做的一下尝试12345&lt;template&gt; &lt;div&gt; &#123;&#123;a&#125;&#125; &lt;/div&gt;&lt;/template&gt; 123456789101112131415 data() &#123; return &#123; a: &#123;&#125;, &#125;; &#125;, created() &#123; setTimeout(() =&gt; &#123; this.a.b = 1; &#125;, 1000) &#125;, watch: &#123; a(newVal, oldVal) &#123; console.log(`$&#123;oldVal&#125;现在变成了$&#123;newVal&#125;`); &#125;,&#125;, 上面这样写(给对象a添加一个本来不存在的属性b,并给他赋值)并不会触发watch, vue文档中也明确表示添加到对象上的新属性不会触发更新,所以我们应该新建一个新的对象并将这个心对象的值赋值给原有的对象12345678910111213141516171819export default &#123; data() &#123; return &#123; a: &#123;&#125;, &#125;; &#125;, created() &#123; setTimeout(() =&gt; &#123; this.a = &#123; b: 1, &#125;; &#125;, 500); &#125;, watch: &#123; a(newVal, oldVal) &#123; console.log(`$&#123;oldVal&#125;现在变成了$&#123;newVal&#125;`); &#125;, &#125;,&#125;; 由此给大家拓展一个对象的一些知识tips1: js取值的两种方式的区别123const obj = &#123;abc:"ss",nn:90&#125;;const v1 = obj.abc; // 使用点的方式const v2 = obj["abc"]; // 使用中括号的方式 在实际项目中一般使用.会方便很多,但是key是变量的话就不能使用.,js对象会理解变量为对象的key值, 1const v3 = obj[key]; tips2: 对象深拷贝实现方法 先解释什么是深拷贝和浅拷贝 浅拷贝是对对象地址的复制,并没有开辟新的栈,复制的结果是两个对象指向同一个地址,修改其中一个对象的属性,另一个对象的属性也会改变 深拷贝是开辟新的栈,两个对象对应两个不同的地址,修改一个对象的属性,不会改变另一个对象的属性 最简单的如下(方法一) 1b = JSON.parse( JSON.stringify(a) ) 但是会存在一些问题 无法复制函数 原型链没了，对象就是object，所属的类没了。 使用递归(方法二) 12345678910111213141516171819202122232425262728const obj1 = &#123; name: 'cehsi', age: 13, friends:['sk','ls'],&#125;function deepCopy(o, c) &#123; var c = c || &#123;&#125;; for(const i in o) &#123; if(typeof o[i] === 'object') &#123; // 判断是对象 if(o[i].constructor === Array) &#123; // 数组 c[i] = []; &#125; else &#123; c[i] = &#123;&#125;; &#125; deepCopy(o[i], c[i]); &#125; else &#123; c[i] = o[i]; &#125; &#125; return c;&#125;let obj2 = &#123;name: 'result'&#125;;obj2 = deepCopy(obj1, obj2);console.log(obj2); // &#123; name: 'cehsi', age: 13, friends: [ 'sk', 'ls' ] &#125;obj2.age = 20;console.log(obj2, obj1); // &#123; name: 'cehsi', age: 20, friends: [ 'sk', 'ls' ] &#125; &#123; name: 'cehsi', age: 13, friends: [ 'sk', 'ls' ] &#125; 使用npm install deepcopy tips3: 深对比,方法参考 http://stackoverflow.com/questions/1068834/object-comparison-in-javascript 方法一:Object.toJSON() 1这个方法简单,但是只适用于两个对象属性相同的情况,在没有方法和DOM节点的情况下，您可以使用简单的JSON样式对象： 123456789101112131415const obj1 = &#123; a: 1, b: 2,&#125;const obj2 = &#123; a: 1, b: 2,&#125;const obj3 = &#123; b: 2, a: 1,&#125;console.log(JSON.stringify(obj1) === JSON.stringify(obj2)); // trueconsole.log(JSON.stringify(obj1) === JSON.stringify(obj3)); // false 方法二: 深度比较两个对象 1比较对象而不挖掘原型，然后递归地比较属性的投影，还可以比较构造函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113function deepCompare(x, y) &#123; var i, l, leftChain, rightChain; function compare2Objects(x, y) &#123; var p; // remember that NaN === NaN returns false // and isNaN(undefined) returns true if (isNaN(x) &amp;&amp; isNaN(y) &amp;&amp; typeof x === 'number' &amp;&amp; typeof y === 'number') &#123; return true; &#125; // Compare primitives and functions. // Check if both arguments link to the same object. // Especially useful on the step where we compare prototypes if (x === y) &#123; return true; &#125; // Works in case when functions are created in constructor. // Comparing dates is a common scenario. Another built-ins? // We can even handle functions passed across iframes if ((typeof x === 'function' &amp;&amp; typeof y === 'function') || (x instanceof Date &amp;&amp; y instanceof Date) || (x instanceof RegExp &amp;&amp; y instanceof RegExp) || (x instanceof String &amp;&amp; y instanceof String) || (x instanceof Number &amp;&amp; y instanceof Number)) &#123; return x.toString() === y.toString(); &#125; // At last checking prototypes as good as we can if (!(x instanceof Object &amp;&amp; y instanceof Object)) &#123; return false; &#125; if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) &#123; return false; &#125; if (x.constructor !== y.constructor) &#123; return false; &#125; if (x.prototype !== y.prototype) &#123; return false; &#125; // Check for infinitive linking loops if (leftChain.indexOf(x) &gt; -1 || rightChain.indexOf(y) &gt; -1) &#123; return false; &#125; // Quick checking of one object being a subset of another. // todo: cache the structure of arguments[0] for performance for (p in y) &#123; if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) &#123; return false; &#125; else if (typeof y[p] !== typeof x[p]) &#123; return false; &#125; &#125; for (p in x) &#123; if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) &#123; return false; &#125; else if (typeof y[p] !== typeof x[p]) &#123; return false; &#125; switch (typeof(x[p])) &#123; case 'object': case 'function': leftChain.push(x); rightChain.push(y); if (!compare2Objects(x[p], y[p])) &#123; return false; &#125; leftChain.pop(); rightChain.pop(); break; default: if (x[p] !== y[p]) &#123; return false; &#125; break; &#125; &#125; return true; &#125; if (arguments.length &lt; 1) &#123; return true; //Die silently? Don't know how to handle such case, please help... // throw "Need two or more arguments to compare"; &#125; for (i = 1, l = arguments.length; i &lt; l; i++) &#123; leftChain = []; //Todo: this can be cached rightChain = []; if (!compare2Objects(arguments[0], arguments[i])) &#123; return false; &#125; &#125; return true;&#125; 已知问题（他们的优先级很低，可能你永远不会注意到） 具有不同原型结构但相同投影的物体 函数可能具有相同的文本，但是指的是不同的闭包原型]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个怎样都不想认输的🌹]]></title>
    <url>%2F2017%2F08%2F22%2F%E4%B8%8D%E6%83%B3%E5%83%8F%E7%94%9F%E6%B4%BB%E4%BD%8E%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[毕业两个月,在北京已待了一年多,我成长了很多,无论技术,还是心理…现在有点开始明白之前为什么一个要晚上十点下班的公司,当时面试技术过了,但是最后却要了一个男生,(最后没被面试上,那个技术面试官还特意打电话说,不是因为你技术不行,而是我们这儿加班很严重,所以综合考虑招了个男同事,让我继续💪); 连续快一个月了,每天晚上一点睡,现在感觉真的身体快吃不消了,昨天上班头疼的已坚持不住,所有跟老大说了一下,晚上八点就早点回去了,电梯里碰到了清洁工阿姨,阿姨会问,吃饭了么,又加班了么,这个点下班真的是太晚了,回去早点休息…(突然想起我妈对我的唠叨) 本来打算晚上回去就睡,躺在床上,突然想起一个解决今天复杂的数据关系的一个思路,于是爬起来打开电脑开始尝试,看了看时间,晚上9点,心里想着最晚11点一定要睡,可是写代码的过程中又遇到很多不会的问题,于是好奇心促使我弄明白我什么… 就这样过了12点…, 一点的时候,实在太困,匆忙把代码传到git上,倒头就睡… 闹钟响了,实在挣不开眼,想着再睡十分钟,一会洗漱一定不墨迹; 10分钟搞定,出门的时候看着天气不对,又赶紧找了把伞,看了一个,好,衣服没穿反,放心的找了辆小黄,骑着飞速跑起来,不好,这两车骑得有点费劲,算了,还是赶紧走吧,有辆车就不错了,路上很堵,堵到一路上都被自行车骑着走,但是心理还是很庆幸自己今天没有做公交车; 到了一个红绿灯路口,看到指挥交通的大爷,等红灯的时候大爷很热情的跟我聊天,说今天要下大雨,问我有没有带雨伞,(有一次因为胃疼差点晕倒,这位大爷看到了就扶了我一下,还打算送我去医院,说小姑娘一个人在外面要好好照顾自己,当时眼泪真的就下来了,在帝都这样冷漠的城市,有个陌生人能对你这样,突然感觉很温暖) 有时候会想是不是自己老了啊,去年这会刚工作,也是每天很累,因为很多东西要学,记得当时每天晚上看书到两点,周末不加班的时候,也是推了很多’约会’,睡上一上午,然后又开始敲代码… 很累的时候,有时候真的是想放弃,有亲戚跟我打电话,说他们那儿招这种刚毕业的学计算机的,一个月刚开始5000,还给解决住房问题,问我要不要考虑回去,毕竟帝都真的很恐怖;可是我刚毕业技术还有很大的上升空间,还是北京这样的大城市技术发展比较好,更能快速成长, 有时候也会想不如拿着自己的高中教师证回去当老师,或者考个公务员,或者找的对自己好的男的,直接结婚,像很多身边的女朋友一样,然后带孩子…可是那样的生活好像一眼就能望到头,那是我喜欢的生活么? 想起当初自己为什么铁了心的要转行,当时也是能想到以后会遇到很多困难,会很累,找工作的时候,学历就是普通本科,专业又是农业,我只能靠自己过硬的技术来比过自己的竞争者. 我正在为自己想要的生活去奋斗,不想平庸的过一辈子,在外面的时候,不要把自己当成一个女生,因为生活并不会因为你是女生而对你手下留情,所有还是像个汉子一样去努力吧,我相信越努力越幸运]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[揭开vue神秘面纱]]></title>
    <url>%2F2017%2F08%2F20%2F%E6%8F%AD%E5%BC%80vue%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%2F</url>
    <content type="text"><![CDATA[带你一步一步走进vue About源码aboutmegithubblog 实现过程,直接上代码1,实现简单的v-model的绑定1234567891011121314151617&lt;body&gt; &lt;input type="text" id="input" v-model="a"/&gt; &lt;p&gt;可以打开控制台,然后输入vm.查看view到model的绑定;然后改变input的值,再次在控制台输出vm.查看model到view的绑定&lt;/p&gt; &lt;!-- &lt;script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"&gt;&lt;/script&gt; --&gt; &lt;script&gt; window.vm = new Vue(&#123; data: &#123; b: 10000, a: 1 &#125;, el: '#input' &#125;); setInterval(() =&gt; &#123; vm.a++; &#125;, 1000); &lt;/script&gt;&lt;/body&gt; 123456789101112131415161718192021222324252627282930function Vue(data) &#123; const input = document.querySelector(data.el); let model = input.getAttribute('v-model'); if(!data.data) &#123; console.warn(`你没有定义data`); return; &#125; if(model &amp;&amp; data.data.hasOwnProperty(model))&#123; // 实现model到view的绑定 input.value = data.data[model]; Object.defineProperty(this, model, &#123; configurable: true, enumerable: true, get: function() &#123; return data.data[model]; &#125;, set: function(newVal) &#123; input.value = data.data[model] = newVal; &#125;, &#125;) // 实现view到model的绑定 input.addEventListener("input", () =&gt; &#123; this[model] = input.value; &#125;); &#125; else &#123; console.warn(`你没有定义$&#123;model&#125;属性`); return; &#125;&#125; 把一个普通 JavaScript 对象传给 Vue 实例的 data选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。 给input添加oninput事件实现view到model的绑定,即在input中输入一个值,vm.a也会跟着发生变化 2,实现多个v-model的绑定123456789101112131415161718192021&lt;body&gt; &lt;div id="form"&gt; &lt;input type="text" v-model="a" /&gt; &lt;br /&gt; &lt;input type="text" v-model="b" /&gt; &lt;div&gt; &lt;input type="text" v-model="c" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- &lt;script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"&gt;&lt;/script&gt; --&gt; &lt;script&gt; window.vm = new Vue(&#123; data: &#123; a: 0, b: 100, c: 2, &#125;, el: '#form' &#125;); &lt;/script&gt;&lt;/body&gt; 123456789101112131415161718192021function Vue(data) &#123; const input = document.querySelectorAll('input'); for (const item of input) &#123; let model = item.getAttribute('v-model'); item.value = data.data[model]; Object.defineProperty(this, model, &#123; configurable: true, enumerable: true, get: function () &#123; return data.data[model]; &#125;, set: function (newVal) &#123; item.value = data.data[model] = newVal; &#125;, &#125;) item.addEventListener("input", () =&gt; &#123; this[model] = item.value; &#125;); &#125;&#125; 实现原理个实现一个v-model差不多 3,实现模板的绑定 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div id="form"&gt; &lt;input type="text" v-model="a" /&gt; &lt;input type="text" v-model="a" /&gt; &lt;p&gt;&#123;&#123; a &#125;&#125;&lt;/p&gt; &lt;br /&gt; &lt;input type="text" v-model="b" /&gt; &#123;&#123; b &#125;&#125; &lt;div&gt; &lt;input type="text" v-model="c" /&gt; &lt;p&gt;&#123;&#123; c &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; c &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- &lt;script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"&gt;&lt;/script&gt; --&gt; &lt;script&gt; window.vm = new Vue(&#123; data: &#123; a: 0, b: 100, c: 2, &#125;, el: '#form' &#125;); console.log(vm); &lt;/script&gt;&lt;/body&gt; 用正则匹配到html中的模板字符串,然后将相应的部分替换成变量 匹配html中多个模板,必须先了解dom的结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function Vue(data) &#123; const input = document.querySelectorAll('input'); for (const item of input) &#123; let model = item.getAttribute('v-model'); item.value = data.data[model]; Object.defineProperty(this, model, &#123; configurable: true, enumerable: true, get: function () &#123; return data.data[model]; &#125;, set: function (newVal) &#123; item.value = data.data[model] = newVal; &#125;, &#125;) item.addEventListener("input", () =&gt; &#123; this[model] = item.value; &#125;); &#125; const pss = document.querySelector(data.el).childNodes; let ps = []; let arr = []; function getText(value) &#123; for (var i = 0, len = value.length; i &lt; len; i++) &#123; if (value[i].nodeType === 1) &#123; getText(value[i].childNodes); &#125; else if (value[i].nodeType === 3) &#123; ps.push(value[i]); &#125; &#125; &#125; getText(pss); const reg = /&#123;&#123;(.*)&#125;&#125;/; ps.forEach((i) =&gt; &#123; if (reg.test(i.nodeValue)) &#123; arr.push(i); &#125; &#125;); console.log(arr); for (const p of arr) &#123; let $p = reg.exec(p.nodeValue)[0].slice(2, p.nodeValue.length - 2).replace(/\s/g, ''); p.nodeValue = data.data[$p]; Object.defineProperty(this, $p, &#123; configurable: true, enumerable: true, get: function () &#123; return data.data[$p]; &#125;, set: function (newVal) &#123; p.nodeValue = data.data[$p] = newVal; &#125;, &#125;) &#125;&#125;// 错在多次赋值被覆盖的错误,所以思路应该变为找到所有绑定a, b, c的值,然后统一赋值 4,实现v-bind,v-on的绑定12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;body&gt; &lt;div id="form"&gt; &lt;h4&gt;这是测试v-model的效果&lt;/h4&gt; &lt;input type="text" v-model="a" /&gt; &lt;input type="text" v-model="a" /&gt; &lt;hr&gt; &lt;h4&gt;这是测试&#123;&#123;&#125;&#125;的效果&lt;/h4&gt; &lt;div&gt;&#123;&#123; a &#125;&#125;&lt;/div&gt; &lt;p&gt;&#123;&#123; a &#125;&#125;&lt;/p&gt; &#123;&#123; a &#125;&#125;&#123;&#123; b &#125;&#125; &lt;br /&gt; &lt;input type="text" v-model="b" /&gt; &lt;p&gt;&#123;&#123; b &#125;&#125;&lt;/p&gt; &lt;div&gt; &lt;input type="text" v-model="c" /&gt; &lt;p&gt;&#123;&#123; c &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;hr&gt; &lt;h4&gt;这是测试v-bind和v-on的效果&lt;/h4&gt; &lt;img v-bind:src="src" v-bind:width="width1" :height="height" v-on:click="log" /&gt; &lt;p&gt;打开控制台,点击img,查看v-on的绑定效果&lt;/p&gt; &lt;/div&gt; &lt;!-- &lt;script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"&gt;&lt;/script&gt; --&gt; &lt;script&gt; window.obj = &#123; a: 0, b: 100, c: '这是测试', src: "http://cdn.suisuijiang.com/message_1492395396308.png?imageView2/2/w/40/h/40", width1: 100, height: 100, &#125;; window.vm = new Vue(&#123; el: '#form', data: obj, methods: &#123; log: function() &#123; console.log('你点击了图片'); console.log(`当前c的值为 $&#123;this.c&#125;`); &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; /** * 解析dom指令 * @param {*} $dom 根节点 * @param {*} instructs 解析结果 */ function handleInstruct($dom, instructs = {}) { function addInstruct(model, type, $node) { if (instructs[model]) { if (instructs[model][type]) { instructs[model][type].push($node); } else { instructs[model][type] = [$node]; } } else { instructs[model] = { [type]: [$node] }; } } if ($dom.attributes) { for (const attr of $dom.attributes) { if (attr.name === 'v-model') { const model = $dom.getAttribute('v-model'); addInstruct(model, 'model', $dom); } else if (/^(v-bind|:)/.test(attr.nodeName)) { const parseResult = attr.nodeName.match(/^(?:v-bind)?:([a-zA-Z_$][a-zA-Z0-9_$]*)/); if (parseResult &amp;&amp; parseResult[1]) { addInstruct(attr.nodeValue.trim(), 'bind', { $dom, attr: parseResult[1] }); } } else if (/^(v-on|@)/.test(attr.name)) { const parseResult = attr.name.match(/^(?:v-on:|@)?([a-zA-Z_$][a-zA-Z0-9_$]*)/); if (parseResult &amp;&amp; parseResult[1]) { addInstruct(attr.nodeValue.trim(), 'on', { $dom, event: parseResult[1] }); } } } } if ($dom.childNodes) { for (const $child of $dom.childNodes) { switch ($child.nodeType) { // ELEMENT_NODE case 1: { handleInstruct($child, instructs); break; } // TEXT_NODE case 3: { const parseResult = $child.data.match(/{{[ ]*([a-zA-Z_$][a-zA-Z0-9_$]*)[ ]*}}/g); if (parseResult) { parseResult.forEach(x =&gt; { const model = x.match(/[a-zA-Z_$][a-zA-Z0-9_$]*/); if (model) { addInstruct(model, 'expression', { $dom: $child, exp: $child.data }); } }); } break; } default: break; } } } return instructs; } function updateDom(vm, instructs, model, shouldRegisterEvent = false) { // 实现v-model的绑定 if (instructs[model].model) { for (const $el of instructs[model].model) { $el.value = vm[model]; if (shouldRegisterEvent) { $el.oninput = () =&gt; { this[model] = $el.value; }; } } } // 实现{{}}的绑定 if (instructs[model].expression) { for (let { $dom, exp } of instructs[model].expression) { const parseResult = exp.match(/{{[ ]*([a-zA-Z_$][a-zA-Z0-9_$]*)[ ]*}}/g); if (parseResult) { parseResult.forEach(x =&gt; { const m = x.match(/[a-zA-Z_$][a-zA-Z0-9_$]*/); if (m) { exp = exp.replace(new RegExp(`{{[ ]*${m[0]}[ ]*}}`), vm[m[0]]); } }); } $dom.textContent = exp; } } // 实现v-bind的绑定 if (instructs[model].bind) { for (const {$dom, attr} of instructs[model].bind) { $dom.setAttribute(attr, vm[model]); } } } function Vue(params) { const $dom = document.querySelector(params.el); if (!$dom) { console.error(`dom "${params.el}" not exist`); return; } const vm = {}; const instructs = handleInstruct($dom); // console.log(instructs); for (const model in instructs) { if (model &amp;&amp; params.data &amp;&amp; Object.prototype.hasOwnProperty.call(params.data, model)) { vm[model] = params.data[model]; Object.defineProperty(this, model, { get: function() { return vm[model]; }, set: function(newValue) { vm[model] = newValue; updateDom(vm, instructs, model); } }); updateDom.call(this, vm, instructs, model, true); } // 实现v-on的绑定 if (instructs[model].on) { for (const { $dom, event } of instructs[model].on) { $dom.addEventListener(event, params.methods[model].bind(this)); } } } } window.Vue = Vue;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小记]]></title>
    <url>%2F2017%2F08%2F12%2F2017-08-11-%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[看到了好多大佬,而且很幸运的中奖了,一个铁三角的耳机~今天早上起来的时候下着雨,本来以为不会有那么多人了,可是到的时候会议室真的是坐满了人;上午将的都是h5游戏的发展,自从2014年7月22日起，’围住神经猫’这款小游戏在微信朋友圈疯传开来之后,h5小游戏就开始非常火,看来js还是很强大的.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for in vs for of]]></title>
    <url>%2F2017%2F07%2F03%2F2017-07-03-for-in-vs-for-of%2F</url>
    <content type="text"><![CDATA[for in 和 for of 的区别 for in 更适合遍历对象，不要使用for in 遍历数组 for in 遍历的是数组的索引(即键名)，而for of 遍历的是数组元素值 12345678910111213141516171819202122232425262728293031323334Object.prototype.methods = function () &#123; console.log(this);&#125;;var myObject = &#123; a: 1, b: 2, c: 3,&#125;;使用for in 遍历对象的键名 for (var key in myObject) &#123; console.log(key); &#125; a b c methodsfor in 可以遍历到myObject的原型方法methods，如果不想遍历原型方法和属性的话.可以用hasOwnPropery方法可以判断某属性是否是该对象的实例属性 for (var key in myObject) &#123; if(myObject.hasOwnProperty(key))&#123; console.log(key); &#125; &#125; a b c console.log(Object.keys(myObject)); [ 'a', 'b', 'c' ]Object.keys(myObject).forEach(function(key, index)&#123; console.log(key, myObject[key]);&#125;) a 1 b 2 c 3 同样可以通过ES5的Object.keys(myObject)获取对象的实例属性组成的数组，不包括原型方法和属性。 for of 用来遍历数组的值]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中scroll的用法]]></title>
    <url>%2F2017%2F06%2F23%2F2017-06-23-vue-scroll%2F</url>
    <content type="text"><![CDATA[12345678910111213141516data () &#123; return &#123; scrolled: false &#125;;&#125;,methods: &#123; handleScroll () &#123; this.scrolled = window.scrollY &gt; 0; &#125;&#125;,created () &#123; window.addEventListener('scroll', this.handleScroll);&#125;,destroyed () &#123; window.removeEventListener('scroll', this.handleScroll);&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程之尾调用]]></title>
    <url>%2F2017%2F06%2F01%2F2017-06-01-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%B0%BE%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[尾调用，就是在函数的最后一步调用另一个函数123function foo(x) &#123; return g(x);&#125; 尾调用不一定出现在函数尾部，只要是最后一步操作就行 123456function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 函数m和n都属于尾调用，他们都是函数的最后一步操作 尾调用优化函数调用会在内存形成一个’调用记录‘，保存调用位置和内部变量等信息，如果在A函数中调用B函数，在A函数的调用记录上还会形成一个B的调用记录，等到B函数运行结束后，把结果返回到A，B的调用记录才会消失。如果函数B内部还调用C函数，那就是还有一个C的调用记录栈，以此类推，所有的调用记录，就会形成一个’调用栈‘。 尾调用在于它特殊的调用位置。由于是函数最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置和内部变量都不会再用到了。 ’尾调用优化‘，只调用内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-redux]]></title>
    <url>%2F2017%2F05%2F24%2F2017-05-24-react-redux%2F</url>
    <content type="text"><![CDATA[reduxredux的三个概念: action reducer store action: 一个包含type的object, 通常把一个返回action对象的函数称为action函数, 直接简称为action 1234567function action(data) &#123; return &#123; type: 'Action1', data, &#125;;&#125; reducer: 一个根据action type来更新数据的函数 123456789101112131415function reducer(state = &#123; data: 1 &#125;, action) &#123; switch (action.type) &#123; case 'action1': &#123; const newState = JSON.parse(JSON.stringify(state)); return newState; &#125; case 'action2': &#123; const newState = JSON.parse(JSON.stringify(state)); return newState; &#125; default: &#123; return state; &#125; &#125;&#125; store: 使用createStore从reducer函数创建的数据对象, 包含getState和dispatch方法 1234567import &#123; createStore &#125; from 'redux';let store = createStore(reducer);console.log(store.getState())store.dispatch(action(0))console.log(store.getState()) 注意! 更新数据需要dispatch对应的action react-redux用于将redux于react结合 Provider: 顶层组件, 注入store对象 12345678import &#123; Provider &#125; from 'react-redux';ReactDom.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('app'),); connect: 工具函数, 参数一为函数, 该函数接收state, 返回一个对象, 对象包含一系列数据. 参数二为函数, 该函数接收dispatch, 返回一个对象, 对象包含一系列方法123456789101112131415161718192021222324252627import &#123; connect &#125; from 'react-redux'; class App extends Component &#123; componentDidMount() &#123; this.props.dispatch(&#123; type: 'action1', data: 1, &#125;); &#125; render() &#123; // this.props.func1(); // this.props.func2(); return ( &lt;div&gt; &lt;/div &gt; ); &#125;&#125;export default connect( state =&gt; (&#123; data: state.data, obj: state.obj, &#125;), dispatch =&gt; (&#123; dispatch &#125;),)(App); immutable.js特殊的object(MAP)/array(LIST) 更新数据: set setIn update updateIn 读取数据: get getIn 可以直接比较(深层比较) 创建(fromJS), 还原(toJS) 123456789101112131415上述的reducer可以用下面的代码优化function reducer(state = immutable.fromJS(&#123; data: 1, obj: &#123; aa: 1 &#125; &#125;), action) &#123; switch (action.type) &#123; case 'action1': &#123; return state.set('data', action.data * 10); &#125; case 'action2': &#123; return state.setIn(['obj', 'aa'], action.data); &#125; default: &#123; return state; &#125; &#125;&#125; 优点 无需深复制, 更新数据自动返回一个新对象 适合与react shouldComponentUpdate结合来优化性能 pure-render-decorator自动创建shouldComponentUpdate的工具, 需要配置babel decorator特性才能使用]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue全家桶+crawler+koa2 实现阴阳师小助手]]></title>
    <url>%2F2017%2F05%2F20%2F2017-5-20-vue%E5%85%A8%E5%AE%B6%E6%A1%B6-crawler-koa2-%E5%AE%9E%E7%8E%B0%E9%98%B4%E9%98%B3%E5%B8%88%E5%B0%8F%E5%8A%A9%E6%89%8B%2F</url>
    <content type="text"><![CDATA[最近一直在玩阴阳师，看了好多小助手，觉得太复杂了，还得登录什么的，想着自己写一个简单的小助手，只要输入要搜索的式神，我想知道的关于这个式神的数据就能显示出来。只是第一版，前端用vue全家桶实现的，很适合刚开始接触vue的，后端用node实现的，如果有更好的建议或者想一起合作写个更好用点的，欢迎联系 作者。 yys-fe(阴阳师小助手前端) A Vue.js project github项目链接 阴阳师小助手后端实现 nodejs + crawler + koa2 + mongoose 效果图 基本- 构建工具：webpack； - 语言：Es6； - 代码规范：eslint - 应用：vue， vuex（数据管理架构）， vue-router（路由）， mint-ui（ul组件）， vue-axios（vue做的ajax请求） 目录结构1234567891011121314151617|-- [build] //构建服务和webpack配置|-- [config] //项目不同环境的配置|-- [dist] //文件服务器根目录 |-- [node_modules] //项目依赖|-- [src] //源码| |-- [assets] //资源文件| |-- [components] //项目模块文件夹| |-- [store] //存储数据| | |-- index.js //vuex store 定义| |-- App.vue //主页面 | |-- main.js //webpack预编译入口| |-- [router] //全局路由定义|-- .babelrc //babel配置|-- .eslintrc.js //eslint rule 定义|-- index.html //项目入口文件|-- package.json //项目配置文件|-- README.md //关于启动项目的命令和含义 已经完成的模块 式神搜索页面(支持模糊搜索) 式神搜索结果页面 式神列表页面 式神详细信息页面 [X] 推荐御魂 [X] 推荐搭配 [X] 式神点评 待完成与优化 搜索功能添加历史搜索和热门搜索 式神攻略 式神视频 页面样式的优化 Build Setup``` bash install dependenciesnpm install serve with hot reload at localhost:8080npm run dev build for production with minificationnpm run build 关于用vue时遇到的坑，记录在我的博客,希望可以对大家有用目前小编在学react，所以用react也写了一版,所以刚开始接触react的童鞋也可以看一下，想着第二版的ui设计的好看一点儿，功能再多一点儿，期待更多的建议。 Aboutaboutmegithubblog]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2017%2F05%2F03%2F2017-05-03-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。 排序算法 冒泡算法 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 12345678910111213function bubbleSort(arr) &#123; for(let i = 0; i &lt; arr.length; i++) &#123; for (var j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;console.log(bubbleSort([1,23,4,3])); 快速排序,通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 1234567891011121314151617function quickSort(arr) &#123; if(arr.length &lt;= 1) &#123; return arr; &#125; let leftArr = []; let rightArr = []; let q = arr[0]; for(let i = 1; i&lt;arr.length;i++) &#123; if(arr[i] &gt; q) &#123; rightArr.push(arr[i]); &#125; else &#123; leftArr.push(arr[i]); &#125; &#125; return [].concat(quickSort(leftArr),[q],quickSort(rightArr));&#125;console.log(quickSort([1,23,4,3]));]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端拿高薪必看面试题]]></title>
    <url>%2F2017%2F05%2F02%2F2017-05-02-js%E7%BB%8F%E5%85%B8%E7%AC%94%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[面试之前都会从网上找很多面试题来看,尤其是看到经典面试题,及必会的面试题,都是好好的看上几遍(其实更多的时候都是在背),可是总感觉面试之前看题作用并不大,因为你不理解的问题,还是会不理解,面试管随便一问,就不行了.其实面试几次后就会发现,经常问的问题也就那几个,比如,闭包,原型链,this,等.刚开始的时候真的是理解不了,然后就看书,强烈推荐以及&lt;你不知道的javascript系列&gt;,在实际项目中遇到坑的时候,就反复看,看的时候很难受,但是当真正理解了之后,就会恍然大悟,所以功夫还是下在平时,临时抱佛脚真的没啥用~ 1,考察this 1234567891011121314var length = 10;function fn() &#123; console.log(this.length);&#125;var obj = &#123; length: 5, method: function(fn) &#123; fn(); arguments[0](); &#125;&#125;;obj.method(fn, 1); 10 ，2 第一次输出10应该没有问题。我们知道取对象属于除了点操作符还可以用中括号，所以第二次执行时相当于arguments调用方法，this指向arguments，而这里传了两个参数，故输出arguments长度为2。 123456789101112131415var length = 10;function fn() &#123; console.log(this.length);&#125;var obj = &#123; length: 5, method: function(fn) &#123; fn(); const fun = arguments[0]; fun()； &#125;&#125;;obj.method(fn, 1); 10 102,var和函数的提前声明 12345678function fn(a) &#123; console.log(a); var a = 2; function a() &#123;&#125; console.log(a); &#125;fn(1); function a() {} 2 var和function是会提前声明的.而且function是优先于var声明的(如果同时存在的话),所以刚开始输出的就是一个funciton,接着往下执行a进行重新赋值了,故第二次输出的是2； 3，局部变量和全局变量1234567891011121314var f = true;if (f === true) &#123; var a = 10;&#125;function fn() &#123; var b = 20; c = 30;&#125;fn();console.log(a);console.log(b);console.log(c); 输出 10 报错 30 这是个我犯了很久的错误，很长一段时间我都以为{…}内的新声明的变量是局部变量，后来我才发现function内的新声明的变量才是局部变量，而没有用var声明的变量在哪里都是全局变量。再次提醒切记只有function(){}内新声明的才能是局部变量，while{…}、if{…}、for(..) 之内的都是全局变量（除非本身包含在function内）。 4，变量隐式声明1234if( 'a' in window) &#123; var a = 10;&#125;console.log(a); 10 funciton和var会提前声明,而其实{…}内的变量也会提前声明，于是代码还没执行前a已经被声明了。所以 ‘a’ in window会返回true,a被赋值 5，给基本类型数据添加属性，不报错，但取值时是undefined1234567var a = 10;a.pro = 10;console.log(a.pro + a);var s = 'hello';s.pro = 'world';console.log(s.pro + s); NaN undefinedhello 给基本类型数据加属性不报错，但是引用的话返回undefined,10+undefined返回NaN,而undefined和string相加时转变成了字符串 6，函数声明优先于变量声明123console.log(typeof fn);function fn() &#123;&#125;;var fn; function 因为函数声明优于变量声明。我们知道在代码逐行执行前，函数声明和变量声明会提前进行，而函数声明又会优于变量声明，这里的优于可以理解为晚于变量声明后，如果函数名和变量名相同，函数声明就能覆盖变量声明。所以以上代码将函数声明和变量声明调换顺序还是一样结果。 7,判断一个字符串中出现次数最多的字符，并统计次数1234567891011121314151617181920var s = 'aaabbbcccaaabbbaaa';var obj = &#123;&#125;;var letter;var maxn = -1;for (let i = 0; i&lt; s.length; i++) &#123; if(obj[s[i]]) &#123; obj[s[i]] ++; if(obj[s[i]] &gt; maxn) &#123; maxn = obj[s[i]]; letter = s[i]; &#125; &#125; else &#123; obj[s[i]] = 1; if(obj[s[i]] &gt; maxn) &#123; maxn = obj[s[i]]; letter = s[i]; &#125; &#125; &#125;console.log(`$&#123;letter&#125;:$&#123;maxn&#125;`); 正则12345678910var s = 'aaabbbcccaaabbbaaa';var a = s.split('');a.sort();s = a.join('');var pattern = /(\w)\1*/g;var ans = s.match(pattern);ans.sort(function(a, b) &#123; return a.length &lt; b.length;&#125;)console.log(ans[0][0] + ':' + ans[0].length); 8， 经典闭包123456789101112131415161718192021222324252627282930&lt;!--html--&gt;&lt;ul&gt; &lt;li&gt;这是第1个&lt;/li&gt; &lt;li&gt;这是第2个&lt;/li&gt; &lt;li&gt;这是第3个&lt;/li&gt; &lt;li&gt;这是第4个&lt;/li&gt;&lt;/ul&gt;&lt;!--js--&gt;一：for(var i = 0; i &lt; lis.length; i++) &#123; lis[i].index = i; lis[i].onclick = function() &#123; alert(this.index); &#125;;&#125;二:for(var i = 0; i &lt; lis.length; i++) &#123; (function(i) &#123; lis[i].onclick = function() &#123; alert(i); &#125;; &#125;)(i); &#125;三：for(let i = 0; i &lt; lis.length; i++) &#123; lis[i].onclick = function() &#123; alert(i); &#125;;&#125; 从0开始隔10s按顺序出现’第一次出现’,’第二次出现’,’第三次出现‘123456789101112131415const datas = ['1', '2', '3'];let timer = null;for (let i = 0; i &lt; datas.length; i++) &#123; // const index = i; if (timer) &#123; clearTimeout(timer); let timer = setTimeout(function () &#123; console.log(datas[i]); &#125;, 10000 * i) &#125; else &#123; let timer = setTimeout(function () &#123; console.log(datas[i]); &#125;, 10000 * i) &#125;&#125;; 9，请编写一个JavaScript函数 parseQueryString，它的用途是把URL参数解析为一个对象，如： var url = “http://witmax.cn/index.php?key0=0&amp;key1=1&amp;key2=2″1234567891011121314function parseQueryString(url) &#123; var obj = &#123;&#125;; var a = url.split('?'); if(a.length === 1) return obj; var b = a[1].split('&amp;'); for(var i = 0, length = b.length; i &lt; length; i++) &#123; var c = b[i].split('='); obj[c[0]] = c[1]; &#125; return obj;&#125;var url = 'http://witmax.cn/index.php?key0=0&amp;key1=1&amp;key2=2';var obj = parseQueryString(url);console.log(obj.key0, obj.key1, obj.key2); // 0 1 2 10,this1234567891011var baz=3;var bazz=&#123; baz: 2, getbaz: function() &#123; return this.baz &#125;&#125;console.log(bazz.getbaz())var g=bazz.getbaz;console.log(g());第一个输出2，第二个输出3,函数作为对象本身属性调用的时候this指向对象，作为普通函数调用的时候就指向全局了 11，数组方法 数组排序:写一个js函数,将数组对象按照一定的顺序进行排序，且可通过参数决定升降序 123456789101112131415161718192021222324const list = [ &#123; "name": "first", "index": 1, &#125;, &#123; "name": "second", "index": 2, &#125;, &#123; "name": "third", "index": 3, &#125;, &#123; "name": "fourth", "index": 4, &#125;,]function compare(property)&#123; return function(a,b)&#123; return a[property] - a[property]; &#125;&#125;console.log(list.sort(compare('index'))) 12,求一个字符串的字节长度12345678910111213function GetBytes(str)&#123; var len = str.length; var bytes = len; for(var i=0; i&lt;len; i++)&#123; if (str.charCodeAt(i) &gt; 255) bytes++; &#125; return bytes; &#125;alert(GetBytes("你好,as"));str = 'hello world';console.log(str.charCodeAt(0)); // 104, 返回指定索引处字符的 Unicode 数值,大于255为中文console.log(str.charAt(0)); // h, 返回指定位置的字符, 13 jsonp原理及过程 利用标签没有跨域限制的“漏洞”（历史遗迹啊）来达到与第三方通讯的目的。 当需要通讯时，本站脚本创建一个元素，地址指向第三方的API网址，形如 并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如：callback({“name”:”hax”,”gender”:”Male”})这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。 14, link和@import区别 link属于html标签，而@import是css提供的。 页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。 link是html标签，因此没有兼容性，而@import只有IE5以上才能识别。 link方式样式的权重高于@import的 15,一个页面从输入url到页面加载显示完成,这个过程都发生了什么? 1,浏览器开启一个线程来处理这个请求 2,查找浏览器缓存(浏览器缓存-系统缓存-路由器缓存) 3,DNS解析,查找该域名对应的IP地址,重定向(301), 4,向真实IP地址服务器发出tcp连接,tcp三次握手 5,握手成功后,进行http协议会话,浏览器发送报头 6,进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器; 7,进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理; 8,处理结束回馈报头，将数据返回至浏览器; 9,浏览器开始下载html文档(响应报头，状态码200)，同时设置缓存; 10,之后浏览器对整个 HTML 结构进行解析，形成 DOM 树；与此同时，它还需要对相应的 CSS 文件进行解析，形成 CSS 树（CSSOM）。 11,得到绘制树之后，需要计算每个结点在页面中的位置，这一个过程称为layout 浏览器这边做的工作大致分为以下几步：加载：根据请求的URL进行域名解析，向服务器发起请求，接收文件（HTML、JS、CSS、图象等）。解析：对加载到的资源（HTML、JS、CSS等）进行语法解析，建议相应的内部数据结构（比如HTML的DOM树，JS的（对象）属性表，CSS的样式规则等等） 16,TCP传输的三次握手四次挥手策略 三次握手 SYN和ACK 发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。 四次挥手 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。17, new操作符到底干了什么?深入了解 1,创建一个空对象,而且this变量引用该对象,同时还继承了该函数的原型. 2,属性和方法被加入到this引用的对象中, 3,新创建的对象由this所引用,而且最后隐式的返回this18, null和undefined的区别? undefined (1)变量被声明了,但是没有赋值,就等于undefined (2)调用函数时,应该提供的参数没有提供,该参数等于undefined (3)对象没有赋值的属性,该属性的值为undefined (4)函数没有返回值时,默认返回undefinednull (1)作为函数的参数,表示该函数的参数不是对象 (2)作为对象原型链的终点 19, js的基本数据类型Number,String,Boolean,Null, Undefined,Object,Symbol 20,DOM怎样添加,移除,复制,和创建节点12345678910111213// 创建新节点createDocumentFragment(); // 创建一个DOM片段createElement(); // 创建一个具体的元素createTextNode(); // 创建一个文本节点//添加,移除,替换appendChild()removeChild()replaceChild()insertBefore() // 在已有的子节点前插入一个新的子节点// 查找getElementByTagName() // 通过标签名称getElementByName() // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)getElementById() // 通过元素ID,唯一性 参考总结这10道javaScript笔试题你都会么正则2016年十家公司面试小记浅谈javascript的函数节流面试题1面试题2面试题3html与css道阻且长啊TAT(前端面试总结),17年春招面试总结 Aboutaboutmegithubblog]]></content>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于斐波那契数列]]></title>
    <url>%2F2017%2F04%2F09%2F2017-04-09-%E5%85%B3%E4%BA%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[用js实现斐波那契数列首先介绍一下，斐波那契数列(Fibonacci sequence)又称黄金分割数列，斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=1，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用， 斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368…….. 这个数列从第3项开始，每一项都等于前两项之和。 实现方法一 1234567891011121314function fib(n) &#123; if(n === 0) &#123; return 0; &#125; else if(n ===1) &#123; return 1; &#125; else &#123; return fib(n-1)+fib(n-2); &#125;&#125;以上的发法是能想到的最直观的实现，现在我们测试一下他的运行结果。fib(1);fib(10)fib(50);运行发现n=1时，会快速输出1，n=10,时，运行速度稍慢，但是当n=10时，运行就非常慢，原因是什么呢，因为n=50时，要进行差不多50次的函数调用，每次调用，都会重新走if的那三个判断条件，而且每次都是从最开始开始计算，当n越大时，性能越差，所以有没有更好的方法来实现它呢？ 实现方法二1234567891011121314151617function fib(n) &#123; if(n === 0) &#123; return 0; &#125; else if(n ===1) &#123; return 1; &#125; else &#123; let a = 0, b = 1; let current = null; for(let i = 2; i &lt;= n; i++) &#123; current = b + a; a = b; b = current; &#125; return current; &#125;&#125;方法二与方法一不同之处在于，最后一个判断加入了一个for循环，current = b + a;当前享等于前两项的和，a = b;把前一项的值赋给a(第前两项)，b = current;把当前值赋给前b(第前一项)，这样当n&gt;1时，只需要在第三个判断走一个循环可以，而不需要一直调用函数，这样做比方法一性能上优化了很多，但是还有没有更好的方法呢? 实现方法三1234567891011121314151617181920212223var cache = &#123; 0: 0, 1: 1&#125;;function fib(n) &#123; return typeof cache[n] === 'number' ? cache[n] : cache[n] = fib(n - 1) + fib(n - 2);&#125;该方法的实现利用了缓存，这样每次计算的时候，都会把计算出的值存放到cache这个缓存中，等下次传入较大的n时，如果缓存中有需要的值，则直接用缓存中的值，这种方法大大提高了函数的性能。还存在一个问题,fib(10000) = Infinity;这有是为什么呢，我们可以从js中数值的取值范围考虑，如何知道js中数值的范围呢， console.log(Number.MAX_VALUE, Number.MIN_VALUE); //取得最大和最小的数console.log(Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);取得最大和最小的整数1.7976931348623157e+308 5e-3249007199254740991 -9007199254740991console.log(fib(400));console.log(fib(500));1.760236806450138e+831.394232245616977e+104n 在大于500的时候差不多已超出范围 如果有更好的方法，欢迎指正]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
