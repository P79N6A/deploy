<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端路由history vs hash]]></title>
    <url>%2F2017%2F10%2F15%2F%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1history-vs-hash%2F</url>
    <content type="text"><![CDATA[history路由机制用户访问网页的历史记录通常会被保存在一个类似栈对象中,即history对象,点击返回就出栈,跳下一页就入栈.它提供了一些方法来操作页面的前进和后退: window.history.back()返回到上一个页面 window.history.forward()进入到下一个页面 window.history.go([delta])跳转到指定页面HTML5对history Api进行了增强,新增了两个Api和一个事件,分别为pushState,replaceState和onpopstatepushState是往history对象里添加一个新的历史记录,即压栈replaceState是替换history对象中的当前历史;这两个API相同之处都会操作浏览器的历史记录,而不会引起页面的刷新;不同之处在于,pushState会增加一条新的历史记录,而replaceState则会替换当前的历史记录当点击浏览器后退按钮或js调用history.back都会触发onpopstate事件,与其类似的还有一个事件:onhashchange hash路由机制我们经常在url中看到#,这个#有两个情况,一个是我们所谓的锚点,比如典型的回到顶部按钮原理,github上各个标题之间的跳转等,路由里的#不叫锚点,我们称之为hash,大型框架的路由系统大多都是哈希实现的onhashchange 事件在当前 URL 的锚部分(以 ‘#’ 号为开始) 发生改变时触发 hashhistory与browserhistory 使用 hashHistory，浏览器上看到的 url 会是这样的: /#/user/haishanh?_k=adseis 使用 browserHistory，浏览器上看到的 url 会是这样的：/user/haishanh 看起来当然browerHistory很好很理想,但browweHistory需要server端支持,而使用hashHistory的时候，因为 url 中 # 符号的存在，从 /#/ 到 /#/user/haishanh 浏览器并不会去发送一次 request，react-router 自己根据 url 去 render 相应的模块。 而使用 browserHistory 的时候，浏览器从 / 到 /user/haishanh 是会向 server 发送 request 的。所以 server 端是要做特殊配置的。比如用的 express 的话，你需要 handle 所有的路由 app.get(‘*’, (req, res) =&gt; { … })，使用了 nginx 的话，nginx也要做相应的配置。所以你的 App 是静态，没有服务端的话，只能用 hashHistory。]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoDB]]></title>
    <url>%2F2017%2F10%2F14%2FmongoDB%2F</url>
    <content type="text"><![CDATA[MongoDB是一个通用的非关系型数据库;把文档存在集合中;它们不需要相同的schema,每个文档都可以有不同的schemaMongoose是一个Node模块;Mongoose的基础知识如下: 打开或关闭MongoDB连接; 注册schema; 添加任务; 搜索文档 更新文档 删除文档首先可以用npm 命令安装Mongoose; 1npm install mongoose 1,连接的打开和关闭装好Mongoose,启动MongoDB服务器,用下面的代码建立到MongoDBd的连接,在下面的例子中是一个叫tasks的数据库12const mongoose = require(' mongoose');const db = mongoose.connect(' mongodb:// localhost/ tasks'); 如果要终止MongoDB创建的连接,1mongoose.disconnect(); 2,注册schema在用MongoDB管理数据时,需要注册schema123456const Schema = mongoose.Schema;const Tasks = new Schema(&#123; project: String, description: String &#125;);mongoose.model(' Task', Tasks); Mongoose的schema很强大.除了定义数据结构,还可以设定默认值,处理输入,以及加强校验 3,添加任务schema注册好后,你可以访问它,让Mongoose去工作,下面的代码用模型添加了一项任务12345678const Task = mongoose. model(' Task');const task = new Task();task.project = 'Bikeshed';task.description = 'Paint the bikeshed red.';task.save( function( err) &#123; if (err) throw err; console.log(' Task saved.');&#125;); 4,搜索文档Task模型的find方法可以用来查找所有文档,或者用一个JavaScript对象指明一个过滤标准来选择特定的文.下面这段代码搜索跟特定项目相关的任务,并输出每项任务的唯一ID和描述1234567const Task = mongoose.model(' Task');Task.find(&#123;' project': 'Bikeshed'&#125;, function( err, tasks) &#123; for (const i = 0; i &lt; tasks.length; i++) &#123; console.log(' ID:' + tasks[ i]._ id); console.log( tasks[ i]. description); &#125;&#125;); 5,更新文档尽管用模型的find方法可以定位一个文档,然后修改并保存它,但Mongoose还有一个update方法专门来做这个.下面的代码用Mongoose更新了一个新的文档 12345678910const Task = mongoose. model(' Task');Task.update( &#123;_id: '4e65b793d0cf5ca508000001'&#125;, // 用 内部 ID 更新 &#123;description: 'Paint the bikeshed green.'&#125;, &#123;multi: false&#125;, //只 更新 一个 文档 function( err, rows_ updated) &#123; if (err) throw err; console.log(' Updated.'); &#125;); 6,删除文档在Mongoose中,一旦你取到了文档,要删除它很容易.你可以用文档的内部ID(或其他任何条件,如果你用find代替finById的话)获取和删除文档,代码就像下面弄这样1234const Task = mongoose.model(' Task');Task.findById(' 4e65b3dce1592f7d08000001', function( err, task)&#123; task. remove();&#125;); 友情链接 robomongo下载]]></content>
      <categories>
        <category>mongoDB</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2017%2F10%2F12%2F2017-10-12-git%2F</url>
    <content type="text"><![CDATA[1,工作区,暂存区,本地仓库,远程仓库 2,git -版本回退本地回退版本1git reset &lt;the-hash&gt; 远程回退版本12git push --force &lt;remote&gt; &lt;the-hash&gt;:&lt;the remote branch&gt; rebase1git rebase -i &lt;the-hash&gt; 清空本地改动1git clean -fd 取消应该被跟踪的改动12git rm --cached &lt;file&gt; 临时取消工作区指定文件改动123git update-index --assume-unchanged &lt;file&gt; git update-index --no-assume-unchanged &lt;file&gt; 3,在master上建了一个分支next,但是master上有改动,需要next主动去合并master分支1next merge master 4,git -远程仓库法人删除和重命名在新版 Git 中可以用 git remote rename 命令修改某个远程仓库在本地的简称，比如想把 pb 改成paul，可以这么运行：1234$ git remote rename pb paul$ git remoteoriginpaul 注意，对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master分支现在成了paul/master。 碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令123$ git remote rm paul$ git remoteorigin git -拉取远程分支1git checkout --track remotes/origin/react 4,git 添加远程仓库地址/拉项目/推项目12345678910111213git remote add mayun https://git.oschina.net/fenmiaojinrong/fmjr.gitgit branch --set-upstream master mayun/mastergit pullgit add .git commit -m&quot;解决冲突&quot;git pushhttp://git.mydoc.io/?t=154712 5,友情链接 windows上Git下载 progit]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年国庆节-杭州&&上海]]></title>
    <url>%2F2017%2F10%2F09%2F2017-10-09-%E5%9B%BD%E5%BA%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[10.01~10.02 coding at home今年的国庆节和中秋节一共八天假,期待了很久的假期;前两天自己在家写了两天代码,研究了一下项目用meteor和react结合做全栈; 10.03 浙大 + 将军山 5点起床,打车去首都机场,前往杭州,打印登机牌,办理行李托运,最后安检的时候被扣下了一瓶海飞丝,(规定是不允许带超过100ml的液体,哎,也是第一次做飞机,平常去的地方都特别近),大概在天上飞了两个半小时,飞机上的风景很美很美,看到了蓝天白云,上午10点左右,到达杭州,跟在天上看到的完全是两个样子,没有蓝天白云. 查找路线,坐公交去定好的酒店,杭州的公交支持支付宝直接付款,这个真的很方便,不用直接去换零钱; 在酒店里休息了一下就开始规划这几天在杭州的路线,浙大就在酒店的附近,就骑着车子去了,杭州的路比北京的要宽很多,路两边的树很多,而且树长的都很大; 浙大玉泉校区 将军山 10.04 西湖 + 杭州海底世界 + 京杭运河来杭州当然一定要去看一下西湖,于是就骑着车子去西湖了,人特别的多, 晚上,游京杭运河,夜景真的很美很美,杭州真的很会使用灯光搭配;武林门码头坐游船,差不多一百元一位,白天有水上的公交,才三元,所以你可以晚上早点去,然后做最后一班公交,这样即会节省一部分开支,又可以看到晚上的夜景 10.05 西溪 + 断桥 大概断桥就是被人压断的吧,O(∩_∩)O哈哈~ 10.06 东方明珠 + 上海世贸大厦最高观光厅 10.07 上海迪士尼迪士尼人真的太多了,基本玩一个项目都得等一个多小时,所以去玩的时候一定要提前做好攻略;(看过欢乐颂2的大概都知道,里面有一个特别浪漫的情节就是在迪士尼拍的,但是电视剧毕竟是电视,看看就好,✧(≖ ◡ ≖✿)嘿嘿,真实的情况你懂得) 10.08 回北京]]></content>
      <categories>
        <category>life</category>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现toolTip]]></title>
    <url>%2F2017%2F09%2F27%2Fcss%E5%AE%9E%E7%8E%B0toolTip%2F</url>
    <content type="text"><![CDATA[1,常用border来实现三角形 原理: 宽高都不设置(即为0),只设置边框,如果4个边框都设置宽度(border-width),样式(border-style)和颜色(border-color)12345678.test &#123; width:0; height: 0; border-top: 100px solid red ; border-bottom: 100px solid blue; border-left: 100px solid green; border-right: 100px solid yellow;&#125; 效果如图 上面看到的都是三角形,其实想实现单个三角形只需把其他三个三角形的border-color设置为透明色就可以了这样就实现了三角形123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;各种三角形&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; margin-top: 50px; &#125; .triangle-up &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid red; &#125; .triangle-down &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid red; &#125; .triangle-left &#123; width: 0; height: 0; border-top: 50px solid transparent; border-right: 100px solid red; border-bottom: 50px solid transparent; &#125; .triangle-right &#123; width: 0; height: 0; border-top: 50px solid transparent; border-left: 100px solid red; border-bottom: 50px solid transparent; &#125; .triangle-topleft &#123; width: 0; height: 0; border-top: 100px solid red; border-right: 100px solid transparent; &#125; .triangle-topright &#123; width: 0; height: 0; border-top: 100px solid red; border-left: 100px solid transparent; &#125; .triangle-bottomleft &#123; width: 0; height: 0; border-bottom: 100px solid red; border-right: 100px solid transparent; &#125; .triangle-bottomright &#123; width: 0; height: 0; border-bottom: 100px solid red; border-left: 100px solid transparent; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li class="triangle-up"&gt;&lt;/li&gt; &lt;li class="triangle-down"&gt;&lt;/li&gt; &lt;li class="triangle-left"&gt;&lt;/li&gt; &lt;li class="triangle-right"&gt;&lt;/li&gt; &lt;li class="triangle-topleft"&gt;&lt;/li&gt; &lt;li class="triangle-topright"&gt;&lt;/li&gt; &lt;li class="triangle-bottomleft"&gt;&lt;/li&gt; &lt;li class="triangle-bottomright"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 2,css实现toolTip(实心三角箭头)原理: 一个三角形绝对定位到主体元素边界处并连接起来 把三角形的颜色换成和主体元素一致的背景色就可以123456789101112131415161718.test &#123; position: relative; width: 300px; height: 100px; border-radius: 20px; margin: 100px auto; background-color: #A5C4EC;&#125;.test:before&#123; content: ''; display: block; position: absolute; bottom: -20px; left: 80px; border-left: 20px solid transparent ; border-right: 20px solid transparent; border-top: 20px solid #A5C4EC;&#125; 3,css实现toolTip(空心三角箭头)源码如下原理: 一个边框颜色的三角形绝对定位到主体元素边界处并连接起来 另一个主体元素背景色的三角形绝对定位并覆盖到第一个三角形上面 第二个三角形相较于第一个三角形定位上偏移距离应等于边框厚度1234567891011121314151617181920212223242526272829.test &#123; position: relative; width: 300px; height: 100px; border-radius: 20px; margin: 100px auto; border: 6px solid blue; background-color: #A5C4EC;&#125;.test:before&#123; content: ''; display: block; position: absolute; bottom: -20px; left: 80px; border-left: 20px solid transparent ; border-right: 20px solid transparent; border-top: 20px solid blue;&#125;.test:after&#123; content: ''; display: block; position: absolute; bottom: -14px; left: 80px; border-left: 20px solid transparent; border-right: 20px solid transparent; border-top: 20px solid #fff;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 1000px; margin: 0 auto; &#125; /* 向下 */ .toolTip-bottom &#123; position: relative; width: 300px; height: 100px; border: 1px solid #A5C4EC; border-radius: 20px; margin: 100px auto; background-color: #fff; &#125; .toolTip-bottom:before&#123; content: ''; display: block; position: absolute; bottom: -20px; left: 80px; border-left: 20px solid transparent ; border-right: 20px solid transparent; border-top: 20px solid #A5C4EC; &#125; .toolTip-bottom:after&#123; content: ''; display: block; position: absolute; bottom: -17.6px; left: 80px; border-left: 20px solid transparent; border-right: 20px solid transparent; border-top: 20px solid #fff; &#125; /* 向上 */ .toolTip-top &#123; position: relative; width: 300px; height: 100px; border: 1px solid #A5C4EC; border-radius: 20px; margin: 100px auto; background-color: #fff; &#125; .toolTip-top:before&#123; content: ''; display: block; position: absolute; top: -20px; left: 80px; border-left: 20px solid transparent ; border-right: 20px solid transparent; border-bottom: 20px solid #A5C4EC; &#125; .toolTip-top:after&#123; content: ''; display: block; position: absolute; top: -17.6px; left: 80px; border-left: 20px solid transparent; border-right: 20px solid transparent; border-bottom: 20px solid #fff; &#125; /* 向左 */ .toolTip-left &#123; position: relative; width: 300px; height: 100px; border: 1px solid #A5C4EC; border-radius: 20px; margin: 100px auto; background-color: #fff; &#125; .toolTip-left:before &#123; content: ''; display: block; position: absolute; left: -20px; top: 30px; border-top: 20px solid transparent ; border-bottom: 20px solid transparent; border-right: 20px solid #A5C4EC; &#125; .toolTip-left:after &#123; content: ''; display: block; position: absolute; left: -18px; top: 30px; border-top: 20px solid transparent ; border-bottom: 20px solid transparent; border-right: 20px solid #fff; &#125; /* 向右 */ .toolTip-right &#123; position: relative; width: 300px; height: 100px; border: 1px solid #A5C4EC; border-radius: 20px; margin: 100px auto; background-color: #fff; &#125; .toolTip-right:before &#123; content: ''; display: block; position: absolute; right: -20px; top: 40px; border-top: 20px solid transparent ; border-bottom: 20px solid transparent; border-left: 20px solid #A5C4EC; &#125; .toolTip-right:after &#123; content: ''; display: block; position: absolute; right: -18px; top: 40px; border-top: 20px solid transparent ; border-bottom: 20px solid transparent; border-left: 20px solid #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;div class="toolTip-bottom"&gt;&lt;/div&gt; &lt;div class="toolTip-top"&gt;&lt;/div&gt; &lt;div class="toolTip-left"&gt;&lt;/div&gt; &lt;div class="toolTip-right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图如下 参考 aboutmegithubblog]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下运行Rocket.chat]]></title>
    <url>%2F2017%2F09%2F17%2FMac%E4%B8%8B%E8%BF%90%E8%A1%8CRocket-chat%2F</url>
    <content type="text"><![CDATA[1,简介 github Rocket.chat是特性最丰富的Slack开源替代品之一 主要功能：群组聊天，直接通信，私聊群，桌面通知，媒体嵌入，文件上传，语音/视频聊天，截图等等 Rocket.chat原生支持windows,Mac OSX, Linux, ios和Android平台 2，准备工作由于Rocket.chat使用的是Meteor框架，而Meteor框架是对Node.js的封装，源码中又使用到了CoffeeScript.js,使用数据库是MongDB，所以在Rocker.chat上做二次开发，需要学习的技术有Meteor, Node.js, CoffeeScript.js,MongDB； 其他资料 CoffeeScipt中文网 Meteor中文网 Rocket.chat要运行，必须安装Node.js,NPM,Meteor(包含了Mongdb)node和npm的安装大家肯定特别熟悉，下面说一下meteor的安装过程 3,安装meteor1curl https://install.meteor.com/ | sh 创建一个小工程的指令，123meteor create meteorAppcd meteorAppmeteor 在浏览器中输入：http://localhost:3000/ 4,下载和运行Rocket.chat下载Rocet.chat最好使用git 的命令1git clone git clone https://github.com/RocketChat/Rocket.Chat.git 等工程源码下载完毕后，进入对应的文件夹，然后运行12cd Rocket.Chatnpm start 在执行npm start的过程中，需要注意一下问题，否则可能会启动不了 1,运行会特别慢,建议加上修改源为淘宝源，具体方法如下参考： 1npm config set registry https://registry.npm.taobao.org 2,运行过程需要翻墙，因为国外的npm包在国内下载可能就被墙了 我在安装的过程中出现报错： 找了phantomjs镜像单独安装了一下速度很快，就成功了,😊,然后把phantomjs添加到环境变量(方法如下)12345671,cd phantomjs2,cd bin3,pwd //注: 需要输出的复制地址4,cd ~ // 回到根目录5,vim .zshrc6,添加到path7,source .zshrc // 保存修改 运行成功命令行如下 运行成功浏览器中如下 参考 如果运行中出现其他的问题欢迎与我交流aboutmegithubblog]]></content>
      <categories>
        <category>meteor</category>
        <category>Rocket.chat</category>
      </categories>
      <tags>
        <tag>meteor</tag>
        <tag>Rocket.chat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心塞！又一次被自己蠢哭]]></title>
    <url>%2F2017%2F09%2F08%2F%E8%A2%AB%E9%AA%97%E8%AE%B0%E2%80%98%2F</url>
    <content type="text"><![CDATA[很晚了，但是今天就是睡不着，想把今天发生在我身上的事情总结一下，看完之后肯定会觉得我很傻很笨，这一次我将不会再为自己辩解；承认自己被骗是一个很痛苦的事情，不知道谁能体会到； 我发现我真的好笨，这次被骗很难过，并不仅仅是骗了200块钱，而是她还欺骗了我的感情，我那么相信她，跟她聊了好多实话，很多人跟我说过不要太容易去相信别人，我爸妈，还有很多朋友都这么跟我说，我很不愿意接受现实生活中哪有那么多坏人，每次都会反驳一句：你们不要老把别人想得那么坏。。。所以就有了之后的一次又一次被骗，之前碰到乞丐都会给一些钱，还有路边说钱包被偷的没钱吃饭的，借钱回家的，还有1700多买了个酷派合约机，一个月话费120(当时都没工作，那来那么多钱交话费)甚至还有骗你拿自己身份证办银行卡的，很多很多，经历了那么多被骗，以为自己现在成熟很多了， 这次美容院被骗事件，我真的是不知道怎么办，只是问个路，然后那个人就拐着你的胳膊就说我领你去，当时还特庆幸自己遇到一个特别好的人，结果就把我领到店里了，我真的很生气，当时准备扭头就走，可是接下来发生的事就像下面百度到的这些美容院骗术发生的一模一样； http://jingyan.baidu.com/article/a17d52855420a78098c8f2f9.html 让脸上抹了一些膏状液体，拿着电疗忆，过一会就变成了黑色(（PS 涂的东西是一种重金属测试膏，百度“美容院用重金属测试膏欺诈顾客”，可以看到相关新闻报道，据说这是十年前就有的骗局。。）)，说是原价700多的现在因为4周年店庆，300多，最后一天，我坚持不做，想走，她死活不让我走，说现在不能走，出去就会感染，过敏，皮囊炎，毁容。。。。(正常人听到这些多少都会还害怕吧，不过现在想想她说怎样就会怎么样么，20多年了，皮肤就这样，很多人一辈子没去去过美容院，也没见自己长着长着毁容的)说你现在不能走，她要对你负责，怎么办，她又说这样吧，给你个学生特惠的190，然后你下次来体验一把全脸的，我意识到这是不掏钱不让走的节奏啊，而且他们人多，我自己，又不敢怎么，但是又不愿相信自己被骗了，还是愿意相信那个人所说的，还傻乎乎的打算有空来体验一把（被自己蠢哭）。 百度完之后，终于意识到自己真的是被骗了，看着百度搜索出来的美容院骗局，解析街边美容院骗局；很多评论都是2017年的。老掉牙的骗局，现在我还被骗，哎，不过看到他们比我骗得钱多，而且很多人都被骗过，心里平衡了很多（明明知道这是一种很不好的心里活动，就当是安慰自己吧） 真的很希望骗子你们不要再找我了，骗我就是一骗一个准，突然想到，自己能安全活这么大还是很不容易的，所以身边的你们要好好珍惜 很渴望骗子能少一些，人与人之前多一点真诚。这样当真正有需要帮助的人需要帮助的时候，大家才不会那么冷漠。希望那些骗子们不要再玩心理战了，这样真的很可恶，不仅骗钱，还骗感情。]]></content>
      <categories>
        <category>life</category>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用vue,你知道 keep-alive 么]]></title>
    <url>%2F2017%2F09%2F06%2Fvue%E7%BB%84%E4%BB%B6%E4%B9%8Bkeep-alive%2F</url>
    <content type="text"><![CDATA[项目中写vue也没注意到&lt;keep-alive&gt;&lt;/keep-alive&gt;这个组件,最近在深入的研究vue组件的生命周期函数,每一个函数都是干嘛的,然后其中有activated和deactivated这两个函数与&lt;keep-alive&gt;&lt;/keep-alive&gt;这个组件有关 activated: keep-alive组件激活时调用 deactivated: keep-alive组件停用时调用keep-alive用法 &lt;keep-alive&gt;包裹动态组件时,会缓存不活动的组件实例,而不是销毁它们 &lt;keep-alive&gt;是一个抽象组件:它自身不会渲染一个DOM元素,也不会出现在父组件链中 当组件在&lt;keep-alive&gt;内被切换,它的activated和deactivated这两个生命周期钩子函数将会被对应执行具体的实例如下 是一个简单的tab切换,可以尝试把&lt;keep-alive&gt;去掉之后,对比一下,然后就会发现它的好处 test.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;div class="test"&gt; &lt;div class="testNav"&gt; &lt;div :class="&#123;'selected':tab === 1,'testTitle':true&#125;" @click="toTab(1)"&gt;标题一&lt;/div&gt; &lt;div :class="&#123;'selected':tab === 2,'testTitle':true&#125;" @click="toTab(2)"&gt;标题二&lt;/div&gt; &lt;/div&gt; &lt;div class="container"&gt; &lt;keep-alive&gt; &lt;Test1 v-if="tab === 1"&gt; &lt;/Test1&gt; &lt;Test2 v-else&gt; &lt;/Test2&gt; &lt;/keep-alive&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Test1 from './test1.vue'; import Test2 from './test2.vue'; export default &#123; data() &#123; return &#123; tab: 1, &#125;; &#125;, components: &#123; Test1, Test2, &#125;, methods: &#123; toTab(index) &#123; this.tab = index; &#125;, &#125;, &#125;&lt;/script&gt;&lt;style lang="less"&gt;.test &#123; width: 100%; .testNav &#123; height: 60px; line-height: 60px; display: flex; border-bottom: 1px solid #e5e5e5; .testTitle &#123; flex: 1; text-align: center; &#125; .selected &#123; color: red; &#125; &#125;&#125;&lt;/style&gt; 测试结果如下:注意看一下页面和控制台输出的信息,可以更加直观的注意到&lt;keep-alive&gt;的作用及activated和deactivated这两个函数什么时候会被触发 打开页面,会出现下面这样 用setTimeout模拟请求后端接口的场景 点击title2,出现下面的情况 再次点击title1,出现下面的情况,你会发现从后端请求的数据会快速显示出来,但是如果你此时不用 test1.vue和test2.vue的相关代码如下: test1.vue123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class="test1"&gt; test1 &#123;&#123;testInfo1&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; testInfo1: '', &#125;; &#125;, activated() &#123; console.log('测试1被激活'); &#125;, deactivated() &#123; console.log('测试1被缓存'); &#125;, created() &#123; setTimeout(() =&gt; &#123; this.testInfo1 = '这是测试一的数据'; &#125;, 2000); &#125;, &#125;&lt;/script&gt; test2.vue123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; test2 &#123;&#123;testInfo2&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; testInfo2: '', &#125; &#125;, activated() &#123; console.log('测试2被激活'); &#125;, deactivated() &#123; console.log('测试2被缓存'); &#125;, created() &#123; setTimeout(() =&gt; &#123; this.testInfo2 = '这是测试二的数据'; &#125;, 2000); &#125;, &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2F2017%2F09%2F06%2Fflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[使用flex布局flex使用方法很简单,只需要将其display属性设置为flex即可,也可以设置行内的flex,记得webkit内核的浏览器,必须加上-webkit, 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。123456.ele &#123; display: -webkit-flex; diaplay: flex; display: inline-flex; display: -webkit-inline-flex;&#125; 在flex中,最核心的概念就是容器和轴,其中容器分为父容器和子容器,轴分为主轴和交叉轴(主轴默认为水平方向,方向向右,交叉轴为主轴顺时针旋转90度) 父容器属性父容器有六个属性 1,flex-direction: 主轴方向. 2,flex-wrap: 超出父容器子容器的排列方式 3,flex-flow: flex-direction属性和flex-wrap属性的简写方式 4,justify-content: 子容器在主轴的排列方向 5,align-items: 子容器的交叉轴上的排列方式 6,align-content: 多根轴线的对齐方式 flex-direciton属性flex-direction属性决定主轴的方向(主轴的方向不一定是水平的,这个属性就是设置主轴的方向,主轴默认是水平方向,从左至右)123456.box &#123; flex-direction: row; // 默认值,主轴为水平方向,起点在左端,从左到右 flex-direction: row-reverse; // 主轴为水平方向,起点在右端,从右到左 flex-direction: column; // 主轴为垂直方向,起点在上端,从上到下 flex-direction: column; // 主轴为垂直方向,起点在下端,从下到上&#125; flex-wrap属性flex-wrap属性决定自容器如果在一条轴线排不下时,如何换行12345.box &#123; flex-wrap: nowrap; // 默认,不换行 flex-wrap: wrap; // 换行,第一行在下面 flex-wrap: column; // 换行,第一行在=上面&#125; 子容器也有6个属性 1,order: 子容器的排列顺序 2,flex-grow: 子容器剩余空间的拉伸比例 3,flex-shrink: 子容器超出空间的压缩比例 4,flex-basis: 子容器不伸缩情况下的原始尺寸 5,flex: 子元素的flex属性是flex-grow, flex-shrink, flex-basis的简写 6,align-self: 允许单个子容器与其他字容器不一样的对齐方式,可覆盖父元素aligns-items属性(交叉轴),默认是auto,表示继承父元素的align-items属性,如果没有付元素,则等同于strech order属性order属性定义子容器的排列顺序,数值越小,排列越靠前123item &#123; order: &lt;interger&gt;&#125; flex-grow属性flex-grow属性定义子容器的放大比例,默认为0123item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果子容器的flex-grow属性都为1,则他们将等分剩余空间(如果有的话).如果一个项目的flex-grow属性为2,其他项目都为1,则前者占据的剩余空间将比其他项多一倍; flex-shrink属性flex-shrink定义了子容器的缩小比例,默认为1,如果空间不足,该项目将缩小123item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有子容器的flex-shrink属性都为1,当空间不足时,都将等比例缩小.如果一个项目的flex-shrink的属性为0,其他项目都为1,则空间不足时,前者不缩小;负值对该属性无效 flex-basis属性flex-basis属性定义了在分配多余空间之前,项目占据了主轴空间,浏览器根据这个属性,计算主轴是否有多余空间.它的默认值为auto,即项目的本来大小;123item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设置跟width和height属性一样的值(比如350px),则项目将占据固定空间 flex属性flex是flex-grow,flex-shrink,flex-basis的缩写,默认值为0 1 auto。后两个属性可选123.item &#123; flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]&#125; align-self属性align-self属性允许单个子容器有与其他子容器不一样的对齐方式，可覆盖align-items属性，默认为auto,表示继承父元素align-items属性，如果没有父元素，则等同于stretch123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto,其他都与align-items属性完全一致。 参考]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除css默认样式的总结]]></title>
    <url>%2F2017%2F09%2F06%2Fcss%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F%E7%9A%84%E6%B8%85%E9%99%A4%2F</url>
    <content type="text"><![CDATA[我们写css的时候经常会遇到要清楚一些默认的样式,其实每次做项目中需要清除的样式就经常是那么几个,最常见的比如 清除表单元素input,select,`textarea的默认样式, CSS3中隐藏滚动条但仍能继续滚动, 多行文本溢出省略号显示等等, 所以就总结了一下,持续更新中…,也请大家多多贡献更多的常见的需要清除默认样式的方法😊 1,多行文本溢出省略号显示 让文本只显示一行，然后溢出省略号显示 123overflow: hidden;text-overflow: ellipsis;white-space: nowrap; 让文本显示两行，然后溢出部分省略号显示12345line-height: 1.3rem;max-height: 2.6rem;display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2; 2，CSS3中隐藏滚动条但仍能继续滚动1234::-webkit-scrollbar &#123; width: 0px; height: 0px;&#125; 3, 解决iPhone中overflow:scroll;滑动速度慢或者卡的问题1-webkit-overflow-scrolling : touch; 4,消除input,textarea等的默认样式123456789input, button, select, textarea &#123; outline: none; -webkit-appearance: none; border-radius: 0; border:0;&#125;textarea&#123; resize:none;&#125; outline: none;去掉chrome浏览器自带的点击input框出现边框情况 -webkit-appearance: button;使元素标签看起来像个按钮样式,意思定义了按钮样式-webkit-appearance: none;去掉按钮样式 border-radius: 0; 去掉圆角border:0; 去掉border textarea{resize:none}取消chrome下textarea可拖动放大：Aboutaboutmegithubblog]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结微信小程序开发中遇到的坑]]></title>
    <url>%2F2017%2F09%2F01%2Fwxapp%2F</url>
    <content type="text"><![CDATA[总结微信小程序开发中遇到的坑,一些坑你得一个一个的跳啊,/(ㄒoㄒ)/~~ 1,页面跳转和参数传递实例 首先说一下我遇到的需求有一个我的消息页面,里面的数据都是后端返回的,返回的数据大致如下,有一个是数据url是要控制跳转到哪个页面,可能是tab页面也可能是非tab页面,但是微信小程序中跳转到tab和非tab页面用的api不是同一个,但是在页面中渲染肯定是要用到循环的,难道要再多个参数来判断是跳转到tab页面还是非tab页面? 1234567891011121314151617[ &#123; "id": 2121, "title": "test", "body": "test", "url": "url", "pic": "pic", "created_at": "2017-07-01 12:34:56" &#125;, &#123; "id": 2122, "title": "test", "body": "test", "url": "url", "pic": "pic", "created_at": "2017-07-01 12:34:56" &#125;,] 后一般的小程序中我用的框架是wepy,底部的tab组件就是我自己写的,没有用到小程序自己提供的那一个,因为我们还要实现一个需求,有消息时,底部tab会出现小红点,还有以下弹窗要把底部tab覆盖掉,这些需求如果用小程序提供的那一个tab组件的话根本实现不了;而且不用wepy框架的话,自己做一个tab实现的过程很恶心,小程序虽然实现了组件化,但是它实现的组件化bong不想vue和react那样实现的是真正的组件化,你需要哪个组件就直接import进来,小程序的组件化实现可查看官方文档,js,css和html都是要分别引入的 自己实现的tab页面整体是一个非tab页面,所有整个小程序中就不存在绝对的tab页面,所以用navigator这个组件,想要跳转到tab页面可以通过在url上拼接参数 123456&lt;view class="mesList" wx:for="&#123;&#123;unReadList&#125;&#125;" wx:key="unique"&gt; &lt;navigator url="/pages/index?tab=0" hover-class="none" &gt; &lt;text&gt;&#123;&#123;item.body&#125;&#125;&lt;/text&gt; &lt;view class="messageTime"&gt;&#123;&#123;item.created_at&#125;&#125;&lt;/view&gt; &lt;/navigator&gt;&lt;/view&gt; 然后再index页面的onload中判断显示哪个tab123456onLoad(options) &#123; if (options &amp;&amp; options.tab) &#123; this.tab = parseInt(options.tab); this.$apply(); &#125;&#125; 2,微信小程序授权处理 微信小程序提示授权弹窗,如果用户第一次点击拒绝之后,一段时间将不会再次弹出来,然后用户又不知道什么原因用不了小程序,这是个很糟糕的用户体验,我们应该优雅的处理这种情况 采用的解决方法参考 3, 登录问题的处理 两个登录接口,一个get,判断是否已经还需要登录,如果返回true,则需要登录,如果返回false,则不需要登录 如果返回true,则需要去请求更一个post的登录接口,这时,你需要获取第一个get请求的返回信息中的session,之后每次请求求都需要带上他 在返回true的时候还需要做一件事儿,就是把返回信息中的session存储到storage,即调用setStorage,然后在之后每次请求数据的时候在headers里加上这个字段1234567891011121314151617181920212223242526272829function getStorage(key) &#123; return new Promise(function (resolve, reject) &#123; // 先判断本地数据存储有没有cookie wx.getStorage(&#123; key: key, success: function (res) &#123; resolve(res.data); &#125;, fail: function (res) &#123; resolve(null); &#125;, &#125;); &#125;);&#125;function setStorage(key, value) &#123; return new Promise(function (resolve, reject) &#123; wx.setStorage(&#123; key: key, data: value, success: function (res) &#123; // TODO: 不知道返回什么 resolve(res.data); &#125;, fail: function (res) &#123; reject(res.errMsg); &#125;, &#125;); &#125;);&#125; 4,wx.getStorage安卓手机上返回的错误信息是getStorage:fail,ios,getStorage:fail data not found 在判断一些api返回的错误信息时,最好不要通过判断具体的错误信息来处理错误12345678910111213141516171819202122function getStorage(key) &#123; return new Promise(function (resolve, reject) &#123; // 先判断本地数据存储有没有cookie wx.getStorage(&#123; key: key, success: function (res) &#123; resolve(res.data); &#125;, fail: function (res) &#123; resolve(null); // 下面注释的部分即为刚开始犯的错误,导致有可能ios或安卓或部分机型显示不出数据 // if (res.errMsg == 'getStorage:fail' || res.errMsg == 'getStorage:fail data not found') &#123; // console.log('没有cookie'); // resolve(null); // &#125; else &#123; // console.log('这是一个问题'); // reject(res.errMsg); // &#125; &#125;, &#125;); &#125;);&#125; 5,小程序解决异步 如果项目中没有用到babal,小程序本身的支持只支持到es6的语法,所以解决异步的问题就不能使用es7的async和await,只能使用promise来解决异步,但是每个api上都进行一次封装(如下),这种做法太恶心了 123456789101112function login() &#123; return new Promise(function (resolve, reject) &#123; wx.login(&#123; success: function (res) &#123; resolve(res); &#125;, fail: function (res) &#123; reject(res.errMsg); &#125;, &#125;); &#125;);&#125; 基于微信的API的prototype上进行了promise的封装 123456789101112131415function promiseify(func) &#123; return (args = &#123;&#125;) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; func.call(wx, Object.assign(args, &#123; success: resolve, fail: reject, &#125;)); &#125;) &#125;&#125;for (const key in wx) &#123; if (Object.prototype.hasOwnProperty.call(wx, key) &amp;&amp; typeof wx[key] === 'function') &#123; wx[`_$&#123;key&#125;`] = promiseify(wx[key]); &#125;&#125; 6,怎么保证在调用其他接口之前已经调用过登录的接口了 我采用执行队列的方式来解决,问题可以简化为有两个按钮,点击第一个按钮输出这是第几次输出d1,但是必须在点击完d2之后,isPrint变为true时,才允许输出,在isPrint为false的时候点击d1,需要把要输出的内容暂时存储起来,等isPrint变为true时,暂存起来的输出现在才可以输出出来12345678910111213141516171819202122232425262728293031323334// html &lt;div class="first"&gt;按钮一&lt;/div&gt; &lt;div class="second"&gt;按钮二&lt;/div&gt;// js const d1 = document.querySelector('.first'); const d2 = document.querySelector('.second'); let count = 0; // 用来记录第几次输出 let isPrint = false; // 是否允许输出 let arr = []; // 声明一个数组,用来存储 function clickCount() &#123; count++; console.log('这是第' + count + '次输出d1'); &#125; d1.onclick = function () &#123; console.log(isPrint); console.log(arr); if (isPrint) &#123; if (arr.length === 0) &#123; clickCount(); &#125; else &#123; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; arr[i](); &#125; &#125; &#125; else &#123; arr.push(clickCount); console.log('不允许输出'); &#125; &#125;; d2.onclick = function () &#123; isPrint = true; console.log(isPrint); &#125; 6,小程序问题 不支持跳转外部链接 text可以解析/n, 目前不支持识别图中二维码， 背景图片不能用本地图片， wx.navigateTo需要跳转的应用内非 tabBar 的页面的路径 wx.switchTab跳转到tabBar页面， wx.showToast(),icon只支持success和loading,但是支持image,且image优先级高于icon tabBar页面A navigatorTo 到页面B，然后B switchTab 到A，这里A会执行onShow()；但是我再从A跳到B再switchTab回来，A就不会再执行onShow()了， 7,总结 有时候在开发者工具上测试时是没有问题的,但是真机测试却有问题,所有开发过程中一定要在多个不同型号的手机上测试;很多时候IOS和安卓api返回的信息不同 在手机上打开调试的时候是好的,但是关闭调试后就会出现各种bug,遇到这种情况一定要一步步的去排查原因 8,后采用wepy重构小程序遇到的一些坑wepy文档1，Q: 怎么在page组件和component组件中回去到getApp(),就是app里面定义的函数,通过this.$parent只能拿到数据，拿不到方法?A:可以在this.$parent的_proto上拿到方法,即this.$parent.onLogin2, Q:怎么实现按需加载A:在compoent组件中自定义生命周期函数,并手动触发]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue生命周期详解]]></title>
    <url>%2F2017%2F08%2F29%2Fvue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[vue声明周期,在每个声明周期中都干了些什么? 1, vue的生命周期 beforeCreate: 组件实例刚刚被创建,组件属性计算之前,如data属性 created: 组件实例创建完成,属性已绑定,但是DOM还未完成,$el属性还不存在 beforeMount:模板编译/挂载之前 mounted: 模板编译/挂载之后 beforeUpdate: 组件更新之前 updated: 组件更新之后 activated: for keep-alive,组件被激活时调用 deactivated: for keep-alive,组件被移除时调用 beforeDestroy: 组件销毁前被调用 destoryed: 组件销毁后调用 ps:下面代码可以直接复制出去执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;script type="text/javascript" src="https://cdn.jsdelivr.net/vue/2.1.3/vue.js"&gt;&lt;/script&gt;&lt;body&gt; &lt;div id="app"&gt;&#123;&#123;a&#125;&#125;&lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; a: 'vuejs', &#125;, beforeCreate: function() &#123; console.log('创建前'); console.log(this.a); console.log(this.$el); &#125;, created: function() &#123; console.log('创建之后'); console.log(this.a); console.log(this.$el); &#125;, beforeMount: function() &#123; console.log('mount之前'); console.log(this.a); console.log(this.$el); &#125;, mounted: function() &#123; console.log('mount之后'); console.log(this.a); console.log(this.$el); &#125;, beforeUpdate: function() &#123; console.log('更新之前'); console.log(this.a); console.log(this.$el); &#125;, updated: function() &#123; console.log('更新完成'); console.log(this.a); console.log(this.$el); &#125;, beforeDestroy: function() &#123; console.log('组件销毁之前'); console.log(this.a); console.log(this.$el); &#125;, destroyed: function() &#123; console.log('组件销毁之后'); console.log(this.a); console.log(this.$el); &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; beforeCreated: el和data并未初始化created: 完成data数据的初始化,el没有beforeMount: 完成了el和data初始化mounted: 完成挂载 1打开命令行在命令行中输入vm.a = &apos;change&apos;;查看效果 activated和deactivated这两个生命周期函数涉及到&lt;keep-alive&gt;这个组件,所以想了解这个生命周期函数的可以看一下我的另一篇文章]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件通信]]></title>
    <url>%2F2017%2F08%2F29%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[组件通信是很重要的一部分,父组件怎么传数据给子组件,子组件怎么传递数据给父组件? 1,父组件给子组件传递数据 vue中使用props向子组件传递数据1): 子组件在props中创建一个属性,用于接收父组件传过来的值2): 父组件中注册子组件3): 在子组件标签中添加子组件props中创建的属性4): 把需要传给子组件的值赋给该属性 2,子组件向父组件传递数据子组件主要通过事件传递数据给父组件1), 子组件中需要以某种方式,例如点击事件的方法来触发一个自定义事件2),将需要传的值作为$emit的第二个参数,该值将作为实参数传给相应自定义事件的方法3),在父组件中注册子组件并在子组件标签上绑定自定义事件的监听 3,子组件向子组件传递数据vue找那个没有直接子组件对子组件传参的方法,建议将需要传递数据的在组件,都合并为一个组件,如果一定需要子组件对子组件传参,可以先传到父组件,再传到子组件,为了方便开发,vue推出了一个状态管理工具vuex,可以啃方便的实现组件之间的参数传递 具体的实例代码如下:可以自行参考相关代码在编辑器中尝试 父组件向子组件传递数据 123456789101112131415161718192021222324252627282930313233// 父组件向子组件传递数据&lt;!--msg 是在data中(父组件)定义的变量如果需要从父组件中获取logo的值,就需要使用props['msg'], 如30行在props中添加了元素以后,就不需要在data中(子组件)中再添加变量了--&gt;&lt;template&gt; &lt;div&gt; &lt;child @transferuser="getUser" :msg="msg"&gt;&lt;/child&gt; &lt;p&gt;用户名为:&#123;&#123;user&#125;&#125;(我是子组件传递给父组件的数据)&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import child from './child.vue'; export default &#123; components: &#123; child, &#125;, data() &#123; return &#123; user: '', msg: '我是父组件传给子组件的信息', &#125;; &#125;, methods: &#123; getUser(msg) &#123; this.user = msg; console.log(msg); &#125;, &#125;, &#125;;&lt;/script&gt; 子组件向父组件传递数据 12345678910111213141516171819202122232425262728293031323334// 子组件向父组件传递数据&lt;!--1.@ : 是 v-on的简写2.子组件主要通过事件传递数据给父组件3.当input的值发生变化时,将username传递给parent.vue,首先声明了一个setUser,用change事件来调用setUser4.在setUser中,使用了$emit来遍历transferUser事件,并返回this.username,其中transferuser是一个自定义事件,功能类似一个中转,this.username通过这个事件传递给父组件--&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;span&gt;用户名&lt;/span&gt; &lt;input v-model="username" @change='setUser'&gt;向父组件传值&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; username: '测试', &#125;; &#125;, props: &#123; msg: &#123; type: String, &#125;, &#125;, methods: &#123; setUser() &#123; this.$emit('transferuser', this.username); &#125;, &#125;, &#125;;&lt;/script&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的函数节流]]></title>
    <url>%2F2017%2F08%2F27%2Fjs%E7%9A%84%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[什么是函数节流?为什么要用到函数节流?函数节流可以解决哪写问题? 函数节流 使用场景: (1)对于常见的场景，如网页滚动时，经常会有滚动到哪时做什么样的动画效果，遂要注册onscroll事件，如何减少触发次数，到达优化性能，同时又满足效果要求不卡顿，一个是优化事件内代码，减少代码量，二就是做函数节流。 (2)在前端开发中，有时会为页面绑定resize事件，或者为一个页面元素绑定拖拽事件（其核心就是绑定mousemove），这种事件有一个特点，就是用户不必特地捣乱，他在一个正常的操作中，都有可能在一个短的时间内触发非常多次事件绑定程序。而大家知道，DOM操作时很消耗性能的，这个时候，如果你为这些事件绑定一些操作DOM节点的操作的话，那就会引发大量的计算，在用户看来，页面可能就一时间没有响应，这个页面一下子变卡了变慢了。甚至在IE下，如果你绑定的resize事件进行较多DOM操作，其高频率可能直接就使得浏览器崩溃。原理 定时器，当触发一个事件时，先setTimeout让这个事件延迟一会再执行，如果在这个时间间隔内又触发了事件，那我们就clear掉原来的定时器，再setTimeout一个新的定时器延迟一会执行 123456789function throttle(method, context) &#123; clearTimeout(method, tId); method.tId = setTimeout(function()&#123; method.call(context); &#125;)&#125;window.onresize = function() &#123; throttle(myFunc);&#125; 1234567891011var throttle = function(fn, delay) &#123; var timer = null; return function() &#123; var context = this, args = arguments; clearTimeout(timer); timer = setTimeout(function() &#123; fn.apply(context, args); &#125;, delay); &#125;&#125;window.onresize = throttle(myFunc, 100); 12345678910111213141516171819var throttleV2 = function (fn, delay, mustRunDelay) &#123; var timer = null; var t_start; return function() &#123; var context = this, args = arguments, t_curr = +new Date(); clearTimeout(timer); if(!t_start) &#123; t_start = t_curr; &#125; if(t_curr - t_start &gt;= mustRunDelay) &#123; fn.apply(context, args); &#125; else &#123; timer = setTimeout(function() &#123; fn.apply(context, args); &#125;, delay); &#125; &#125;&#125;window.onresize = throttleV2(myFunc, 50, 100);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js垃圾回收机制]]></title>
    <url>%2F2017%2F08%2F27%2Fjs%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[你了解javascript的垃圾回收机制么? 引用计数此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。 标记清除当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。 垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个怎样都不想认输的🌹]]></title>
    <url>%2F2017%2F08%2F26%2F%E4%B8%8D%E6%83%B3%E5%83%8F%E7%94%9F%E6%B4%BB%E4%BD%8E%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[毕业两个月,在北京已待了一年多,我成长了很多,无论技术,还是心理…现在有点开始明白之前为什么一个要晚上十点下班的公司,当时面试技术过了,但是最后却要了一个男生,(最后没被面试上,那个技术面试官还特意打电话说,不是因为你技术不行,而是我们这儿加班很严重,所以综合考虑招了个男同事,让我继续💪); 连续快一个月了,每天晚上一点睡,现在感觉真的身体快吃不消了,昨天上班头疼的已坚持不住,所有跟老大说了一下,晚上八点就早点回去了,电梯里碰到了清洁工阿姨,阿姨会问,吃饭了么,又加班了么,这个点下班真的是太晚了,回去早点休息…(突然想起我妈对我的唠叨) 本来打算晚上回去就睡,躺在床上,突然想起一个解决今天复杂的数据关系的一个思路,于是爬起来打开电脑开始尝试,看了看时间,晚上9点,心里想着最晚11点一定要睡,可是写代码的过程中又遇到很多不会的问题,于是好奇心促使我弄明白我什么… 就这样过了12点…, 一点的时候,实在太困,匆忙把代码传到git上,倒头就睡… 闹钟响了,实在挣不开眼,想着再睡十分钟,一会洗漱一定不墨迹; 10分钟搞定,出门的时候看着天气不对,又赶紧找了把伞,看了一个,好,衣服没穿反,放心的找了辆小黄,骑着飞速跑起来,不好,这两车骑得有点费劲,算了,还是赶紧走吧,有辆车就不错了,路上很堵,堵到一路上都被自行车骑着走,但是心理还是很庆幸自己今天没有做公交车; 到了一个红绿灯路口,看到指挥交通的大爷,等红灯的时候大爷很热情的跟我聊天,说今天要下大雨,问我有没有带雨伞,(有一次因为胃疼差点晕倒,这位大爷看到了就扶了我一下,还打算送我去医院,说小姑娘一个人在外面要好好照顾自己,当时眼泪真的就下来了,在帝都这样冷漠的城市,有个陌生人能对你这样,突然感觉很温暖) 有时候会想是不是自己老了啊,去年这会刚工作,也是每天很累,因为很多东西要学,记得当时每天晚上看书到两点,周末不加班的时候,也是推了很多’约会’,睡上一上午,然后又开始敲代码… 很累的时候,有时候真的是想放弃,有亲戚跟我打电话,说他们那儿招这种刚毕业的学计算机的,一个月刚开始5000,还给解决住房问题,问我要不要考虑回去,毕竟帝都真的很恐怖;可是我刚毕业技术还有很大的上升空间,还是北京这样的大城市技术发展比较好,更能快速成长, 有时候也会想不如拿着自己的高中教师证回去当老师,或者考个公务员,或者找的对自己好的男的,直接结婚,像很多身边的女朋友一样,然后带孩子…可是那样的生活好像一眼就能望到头,那是我喜欢的生活么? 想起当初自己为什么铁了心的要转行,当时也是能想到以后会遇到很多困难,会很累,找工作的时候,学历就是普通本科,专业又是农业,我只能靠自己过硬的技术来比过自己的竞争者. 我正在为自己想要的生活去奋斗,不想平庸的过一辈子,在外面的时候,不要把自己当成一个女生,因为生活并不会因为你是女生而对你手下留情,所有还是像个汉子一样去努力吧,我相信越努力越幸运]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嘿,使用vue,你注意到了这些了么?]]></title>
    <url>%2F2017%2F08%2F23%2Fvue%E4%B8%AD%E6%A3%80%E6%B5%8B%E4%B8%8D%E5%88%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[使用vue过程中,遇到了一些问题,这里先总结以下两个: 问题一:vue组件之间传递数据,在子组件中我想改变一个从父组件中传过来的值 这是父组件1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;Child :message="message"&gt;&lt;/Child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from './child.vue';export default &#123; data() &#123; return &#123; message: '这是传给子组件的信息', &#125;; &#125;, components: &#123; Child, &#125;,&#125;;&lt;/script&gt; 这是子组件123456789101112131415161718192021&lt;template&gt; &lt;div @click="handleChange"&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; message: &#123; type: String, default: '这是默认信息', &#125;, &#125;, methods: &#123; handleChange() &#123; this.message = '我是子组件修改后的信息'; &#125;, &#125;, &#125;;&lt;/script&gt; 如果你这样写就会报一下错误但是在子组件中，我们不要去修改 prop。如果你必须要修改到这些数据，你可以使用以下方法： 把 prop 赋值给一个局部变量，然后需要修改的话就修改这个局部变量，而不影响 prop1234567891011121314151617181920212223242526&lt;template&gt; &lt;div @click="handleChange"&gt; &#123;&#123;newMessage&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; message: &#123; type: String, default: '这是默认信息', &#125;, &#125;, data() &#123; return &#123; newMessage: this.message, &#125;; &#125;, methods: &#123; handleChange() &#123; this.newMessage = '我是子组件修改后的信息'; &#125;, &#125;, &#125;;&lt;/script&gt; 问题二:vue中检测不到data的变化,我想把给data中的a赋值一个新的对象(添加一个它本身不存在的属性),然而经过尝试发现直接赋值是行不通的,以下是我做的一下尝试12345&lt;template&gt; &lt;div&gt; &#123;&#123;a&#125;&#125; &lt;/div&gt;&lt;/template&gt; 123456789101112131415 data() &#123; return &#123; a: &#123;&#125;, &#125;; &#125;, created() &#123; setTimeout(() =&gt; &#123; this.a.b = 1; &#125;, 1000) &#125;, watch: &#123; a(newVal, oldVal) &#123; console.log(`$&#123;oldVal&#125;现在变成了$&#123;newVal&#125;`); &#125;,&#125;, 上面这样写(给对象a添加一个本来不存在的属性b,并给他赋值)并不会触发watch, vue文档中也明确表示添加到对象上的新属性不会触发更新,所以我们应该新建一个新的对象并将这个心对象的值赋值给原有的对象12345678910111213141516171819export default &#123; data() &#123; return &#123; a: &#123;&#125;, &#125;; &#125;, created() &#123; setTimeout(() =&gt; &#123; this.a = &#123; b: 1, &#125;; &#125;, 500); &#125;, watch: &#123; a(newVal, oldVal) &#123; console.log(`$&#123;oldVal&#125;现在变成了$&#123;newVal&#125;`); &#125;, &#125;,&#125;; 由此给大家拓展一个对象的一些知识tips1: js取值的两种方式的区别123const obj = &#123;abc:"ss",nn:90&#125;;const v1 = obj.abc; // 使用点的方式const v2 = obj["abc"]; // 使用中括号的方式 在实际项目中一般使用.会方便很多,但是key是变量的话就不能使用.,js对象会理解变量为对象的key值, 1const v3 = obj[key]; tips2: 对象深拷贝实现方法 先解释什么是深拷贝和浅拷贝 浅拷贝是对对象地址的复制,并没有开辟新的栈,复制的结果是两个对象指向同一个地址,修改其中一个对象的属性,另一个对象的属性也会改变 深拷贝是开辟新的栈,两个对象对应两个不同的地址,修改一个对象的属性,不会改变另一个对象的属性 最简单的如下(方法一) 1b = JSON.parse( JSON.stringify(a) ) 但是会存在一些问题 无法复制函数 原型链没了，对象就是object，所属的类没了。 使用递归(方法二) 12345678910111213141516171819202122232425262728const obj1 = &#123; name: 'cehsi', age: 13, friends:['sk','ls'],&#125;function deepCopy(o, c) &#123; var c = c || &#123;&#125;; for(const i in o) &#123; if(typeof o[i] === 'object') &#123; // 判断是对象 if(o[i].constructor === Array) &#123; // 数组 c[i] = []; &#125; else &#123; c[i] = &#123;&#125;; &#125; deepCopy(o[i], c[i]); &#125; else &#123; c[i] = o[i]; &#125; &#125; return c;&#125;let obj2 = &#123;name: 'result'&#125;;obj2 = deepCopy(obj1, obj2);console.log(obj2); // &#123; name: 'cehsi', age: 13, friends: [ 'sk', 'ls' ] &#125;obj2.age = 20;console.log(obj2, obj1); // &#123; name: 'cehsi', age: 20, friends: [ 'sk', 'ls' ] &#125; &#123; name: 'cehsi', age: 13, friends: [ 'sk', 'ls' ] &#125; 使用npm install deepcopy tips3: 深对比,方法参考 http://stackoverflow.com/questions/1068834/object-comparison-in-javascript 方法一:Object.toJSON() 1这个方法简单,但是只适用于两个对象属性相同的情况,在没有方法和DOM节点的情况下，您可以使用简单的JSON样式对象： 123456789101112131415const obj1 = &#123; a: 1, b: 2,&#125;const obj2 = &#123; a: 1, b: 2,&#125;const obj3 = &#123; b: 2, a: 1,&#125;console.log(JSON.stringify(obj1) === JSON.stringify(obj2)); // trueconsole.log(JSON.stringify(obj1) === JSON.stringify(obj3)); // false 方法二: 深度比较两个对象 1比较对象而不挖掘原型，然后递归地比较属性的投影，还可以比较构造函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113function deepCompare(x, y) &#123; var i, l, leftChain, rightChain; function compare2Objects(x, y) &#123; var p; // remember that NaN === NaN returns false // and isNaN(undefined) returns true if (isNaN(x) &amp;&amp; isNaN(y) &amp;&amp; typeof x === 'number' &amp;&amp; typeof y === 'number') &#123; return true; &#125; // Compare primitives and functions. // Check if both arguments link to the same object. // Especially useful on the step where we compare prototypes if (x === y) &#123; return true; &#125; // Works in case when functions are created in constructor. // Comparing dates is a common scenario. Another built-ins? // We can even handle functions passed across iframes if ((typeof x === 'function' &amp;&amp; typeof y === 'function') || (x instanceof Date &amp;&amp; y instanceof Date) || (x instanceof RegExp &amp;&amp; y instanceof RegExp) || (x instanceof String &amp;&amp; y instanceof String) || (x instanceof Number &amp;&amp; y instanceof Number)) &#123; return x.toString() === y.toString(); &#125; // At last checking prototypes as good as we can if (!(x instanceof Object &amp;&amp; y instanceof Object)) &#123; return false; &#125; if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) &#123; return false; &#125; if (x.constructor !== y.constructor) &#123; return false; &#125; if (x.prototype !== y.prototype) &#123; return false; &#125; // Check for infinitive linking loops if (leftChain.indexOf(x) &gt; -1 || rightChain.indexOf(y) &gt; -1) &#123; return false; &#125; // Quick checking of one object being a subset of another. // todo: cache the structure of arguments[0] for performance for (p in y) &#123; if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) &#123; return false; &#125; else if (typeof y[p] !== typeof x[p]) &#123; return false; &#125; &#125; for (p in x) &#123; if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) &#123; return false; &#125; else if (typeof y[p] !== typeof x[p]) &#123; return false; &#125; switch (typeof(x[p])) &#123; case 'object': case 'function': leftChain.push(x); rightChain.push(y); if (!compare2Objects(x[p], y[p])) &#123; return false; &#125; leftChain.pop(); rightChain.pop(); break; default: if (x[p] !== y[p]) &#123; return false; &#125; break; &#125; &#125; return true; &#125; if (arguments.length &lt; 1) &#123; return true; //Die silently? Don't know how to handle such case, please help... // throw "Need two or more arguments to compare"; &#125; for (i = 1, l = arguments.length; i &lt; l; i++) &#123; leftChain = []; //Todo: this can be cached rightChain = []; if (!compare2Objects(arguments[0], arguments[i])) &#123; return false; &#125; &#125; return true;&#125; 已知问题（他们的优先级很低，可能你永远不会注意到） 具有不同原型结构但相同投影的物体 函数可能具有相同的文本，但是指的是不同的闭包原型]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[揭开vue神秘面纱]]></title>
    <url>%2F2017%2F08%2F20%2F%E6%8F%AD%E5%BC%80vue%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%2F</url>
    <content type="text"><![CDATA[带你一步一步走进vue About源码aboutmegithubblog 实现过程,直接上代码1,实现简单的v-model的绑定1234567891011121314151617&lt;body&gt; &lt;input type="text" id="input" v-model="a"/&gt; &lt;p&gt;可以打开控制台,然后输入vm.查看view到model的绑定;然后改变input的值,再次在控制台输出vm.查看model到view的绑定&lt;/p&gt; &lt;!-- &lt;script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"&gt;&lt;/script&gt; --&gt; &lt;script&gt; window.vm = new Vue(&#123; data: &#123; b: 10000, a: 1 &#125;, el: '#input' &#125;); setInterval(() =&gt; &#123; vm.a++; &#125;, 1000); &lt;/script&gt;&lt;/body&gt; 123456789101112131415161718192021222324252627282930function Vue(data) &#123; const input = document.querySelector(data.el); let model = input.getAttribute('v-model'); if(!data.data) &#123; console.warn(`你没有定义data`); return; &#125; if(model &amp;&amp; data.data.hasOwnProperty(model))&#123; // 实现model到view的绑定 input.value = data.data[model]; Object.defineProperty(this, model, &#123; configurable: true, enumerable: true, get: function() &#123; return data.data[model]; &#125;, set: function(newVal) &#123; input.value = data.data[model] = newVal; &#125;, &#125;) // 实现view到model的绑定 input.addEventListener("input", () =&gt; &#123; this[model] = input.value; &#125;); &#125; else &#123; console.warn(`你没有定义$&#123;model&#125;属性`); return; &#125;&#125; 把一个普通 JavaScript 对象传给 Vue 实例的 data选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。 给input添加oninput事件实现view到model的绑定,即在input中输入一个值,vm.a也会跟着发生变化 2,实现多个v-model的绑定123456789101112131415161718192021&lt;body&gt; &lt;div id="form"&gt; &lt;input type="text" v-model="a" /&gt; &lt;br /&gt; &lt;input type="text" v-model="b" /&gt; &lt;div&gt; &lt;input type="text" v-model="c" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- &lt;script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"&gt;&lt;/script&gt; --&gt; &lt;script&gt; window.vm = new Vue(&#123; data: &#123; a: 0, b: 100, c: 2, &#125;, el: '#form' &#125;); &lt;/script&gt;&lt;/body&gt; 123456789101112131415161718192021function Vue(data) &#123; const input = document.querySelectorAll('input'); for (const item of input) &#123; let model = item.getAttribute('v-model'); item.value = data.data[model]; Object.defineProperty(this, model, &#123; configurable: true, enumerable: true, get: function () &#123; return data.data[model]; &#125;, set: function (newVal) &#123; item.value = data.data[model] = newVal; &#125;, &#125;) item.addEventListener("input", () =&gt; &#123; this[model] = item.value; &#125;); &#125;&#125; 实现原理个实现一个v-model差不多 3,实现模板的绑定 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div id="form"&gt; &lt;input type="text" v-model="a" /&gt; &lt;input type="text" v-model="a" /&gt; &lt;p&gt;&#123;&#123; a &#125;&#125;&lt;/p&gt; &lt;br /&gt; &lt;input type="text" v-model="b" /&gt; &#123;&#123; b &#125;&#125; &lt;div&gt; &lt;input type="text" v-model="c" /&gt; &lt;p&gt;&#123;&#123; c &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; c &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- &lt;script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"&gt;&lt;/script&gt; --&gt; &lt;script&gt; window.vm = new Vue(&#123; data: &#123; a: 0, b: 100, c: 2, &#125;, el: '#form' &#125;); console.log(vm); &lt;/script&gt;&lt;/body&gt; 用正则匹配到html中的模板字符串,然后将相应的部分替换成变量 匹配html中多个模板,必须先了解dom的结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function Vue(data) &#123; const input = document.querySelectorAll('input'); for (const item of input) &#123; let model = item.getAttribute('v-model'); item.value = data.data[model]; Object.defineProperty(this, model, &#123; configurable: true, enumerable: true, get: function () &#123; return data.data[model]; &#125;, set: function (newVal) &#123; item.value = data.data[model] = newVal; &#125;, &#125;) item.addEventListener("input", () =&gt; &#123; this[model] = item.value; &#125;); &#125; const pss = document.querySelector(data.el).childNodes; let ps = []; let arr = []; function getText(value) &#123; for (var i = 0, len = value.length; i &lt; len; i++) &#123; if (value[i].nodeType === 1) &#123; getText(value[i].childNodes); &#125; else if (value[i].nodeType === 3) &#123; ps.push(value[i]); &#125; &#125; &#125; getText(pss); const reg = /&#123;&#123;(.*)&#125;&#125;/; ps.forEach((i) =&gt; &#123; if (reg.test(i.nodeValue)) &#123; arr.push(i); &#125; &#125;); console.log(arr); for (const p of arr) &#123; let $p = reg.exec(p.nodeValue)[0].slice(2, p.nodeValue.length - 2).replace(/\s/g, ''); p.nodeValue = data.data[$p]; Object.defineProperty(this, $p, &#123; configurable: true, enumerable: true, get: function () &#123; return data.data[$p]; &#125;, set: function (newVal) &#123; p.nodeValue = data.data[$p] = newVal; &#125;, &#125;) &#125;&#125;// 错在多次赋值被覆盖的错误,所以思路应该变为找到所有绑定a, b, c的值,然后统一赋值 4,实现v-bind,v-on的绑定12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;body&gt; &lt;div id="form"&gt; &lt;h4&gt;这是测试v-model的效果&lt;/h4&gt; &lt;input type="text" v-model="a" /&gt; &lt;input type="text" v-model="a" /&gt; &lt;hr&gt; &lt;h4&gt;这是测试&#123;&#123;&#125;&#125;的效果&lt;/h4&gt; &lt;div&gt;&#123;&#123; a &#125;&#125;&lt;/div&gt; &lt;p&gt;&#123;&#123; a &#125;&#125;&lt;/p&gt; &#123;&#123; a &#125;&#125;&#123;&#123; b &#125;&#125; &lt;br /&gt; &lt;input type="text" v-model="b" /&gt; &lt;p&gt;&#123;&#123; b &#125;&#125;&lt;/p&gt; &lt;div&gt; &lt;input type="text" v-model="c" /&gt; &lt;p&gt;&#123;&#123; c &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;hr&gt; &lt;h4&gt;这是测试v-bind和v-on的效果&lt;/h4&gt; &lt;img v-bind:src="src" v-bind:width="width1" :height="height" v-on:click="log" /&gt; &lt;p&gt;打开控制台,点击img,查看v-on的绑定效果&lt;/p&gt; &lt;/div&gt; &lt;!-- &lt;script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"&gt;&lt;/script&gt; --&gt; &lt;script&gt; window.obj = &#123; a: 0, b: 100, c: '这是测试', src: "http://cdn.suisuijiang.com/message_1492395396308.png?imageView2/2/w/40/h/40", width1: 100, height: 100, &#125;; window.vm = new Vue(&#123; el: '#form', data: obj, methods: &#123; log: function() &#123; console.log('你点击了图片'); console.log(`当前c的值为 $&#123;this.c&#125;`); &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; /** * 解析dom指令 * @param {*} $dom 根节点 * @param {*} instructs 解析结果 */ function handleInstruct($dom, instructs = {}) { function addInstruct(model, type, $node) { if (instructs[model]) { if (instructs[model][type]) { instructs[model][type].push($node); } else { instructs[model][type] = [$node]; } } else { instructs[model] = { [type]: [$node] }; } } if ($dom.attributes) { for (const attr of $dom.attributes) { if (attr.name === 'v-model') { const model = $dom.getAttribute('v-model'); addInstruct(model, 'model', $dom); } else if (/^(v-bind|:)/.test(attr.nodeName)) { const parseResult = attr.nodeName.match(/^(?:v-bind)?:([a-zA-Z_$][a-zA-Z0-9_$]*)/); if (parseResult &amp;&amp; parseResult[1]) { addInstruct(attr.nodeValue.trim(), 'bind', { $dom, attr: parseResult[1] }); } } else if (/^(v-on|@)/.test(attr.name)) { const parseResult = attr.name.match(/^(?:v-on:|@)?([a-zA-Z_$][a-zA-Z0-9_$]*)/); if (parseResult &amp;&amp; parseResult[1]) { addInstruct(attr.nodeValue.trim(), 'on', { $dom, event: parseResult[1] }); } } } } if ($dom.childNodes) { for (const $child of $dom.childNodes) { switch ($child.nodeType) { // ELEMENT_NODE case 1: { handleInstruct($child, instructs); break; } // TEXT_NODE case 3: { const parseResult = $child.data.match(/{{[ ]*([a-zA-Z_$][a-zA-Z0-9_$]*)[ ]*}}/g); if (parseResult) { parseResult.forEach(x =&gt; { const model = x.match(/[a-zA-Z_$][a-zA-Z0-9_$]*/); if (model) { addInstruct(model, 'expression', { $dom: $child, exp: $child.data }); } }); } break; } default: break; } } } return instructs; } function updateDom(vm, instructs, model, shouldRegisterEvent = false) { // 实现v-model的绑定 if (instructs[model].model) { for (const $el of instructs[model].model) { $el.value = vm[model]; if (shouldRegisterEvent) { $el.oninput = () =&gt; { this[model] = $el.value; }; } } } // 实现{{}}的绑定 if (instructs[model].expression) { for (let { $dom, exp } of instructs[model].expression) { const parseResult = exp.match(/{{[ ]*([a-zA-Z_$][a-zA-Z0-9_$]*)[ ]*}}/g); if (parseResult) { parseResult.forEach(x =&gt; { const m = x.match(/[a-zA-Z_$][a-zA-Z0-9_$]*/); if (m) { exp = exp.replace(new RegExp(`{{[ ]*${m[0]}[ ]*}}`), vm[m[0]]); } }); } $dom.textContent = exp; } } // 实现v-bind的绑定 if (instructs[model].bind) { for (const {$dom, attr} of instructs[model].bind) { $dom.setAttribute(attr, vm[model]); } } } function Vue(params) { const $dom = document.querySelector(params.el); if (!$dom) { console.error(`dom "${params.el}" not exist`); return; } const vm = {}; const instructs = handleInstruct($dom); // console.log(instructs); for (const model in instructs) { if (model &amp;&amp; params.data &amp;&amp; Object.prototype.hasOwnProperty.call(params.data, model)) { vm[model] = params.data[model]; Object.defineProperty(this, model, { get: function() { return vm[model]; }, set: function(newValue) { vm[model] = newValue; updateDom(vm, instructs, model); } }); updateDom.call(this, vm, instructs, model, true); } // 实现v-on的绑定 if (instructs[model].on) { for (const { $dom, event } of instructs[model].on) { $dom.addEventListener(event, params.methods[model].bind(this)); } } } } window.Vue = Vue;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小记-iweb峰会]]></title>
    <url>%2F2017%2F08%2F12%2F2017-08-11-%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[看到了好多大佬,而且很幸运的中奖了,一个金三角的耳机~今天早上起来的时候下着雨,本来以为不会有那么多人了,可是到的时候会议室真的是坐满了人;上午将的都是h5游戏的发展,自从2014年7月22日起，’围住神经猫’这款小游戏在微信朋友圈疯传开来之后,h5小游戏就开始非常火,看来js还是很强大的.]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for in vs for of]]></title>
    <url>%2F2017%2F07%2F03%2F2017-07-03-for-in-vs-for-of%2F</url>
    <content type="text"><![CDATA[for in 和 for of 的区别 for in 更适合遍历对象，不要使用for in 遍历数组 for in 遍历的是数组的索引(即键名)，而for of 遍历的是数组元素值 12345678910111213141516171819202122232425262728293031323334Object.prototype.methods = function () &#123; console.log(this);&#125;;var myObject = &#123; a: 1, b: 2, c: 3,&#125;;使用for in 遍历对象的键名 for (var key in myObject) &#123; console.log(key); &#125; a b c methodsfor in 可以遍历到myObject的原型方法methods，如果不想遍历原型方法和属性的话.可以用hasOwnPropery方法可以判断某属性是否是该对象的实例属性 for (var key in myObject) &#123; if(myObject.hasOwnProperty(key))&#123; console.log(key); &#125; &#125; a b c console.log(Object.keys(myObject)); [ 'a', 'b', 'c' ]Object.keys(myObject).forEach(function(key, index)&#123; console.log(key, myObject[key]);&#125;) a 1 b 2 c 3 同样可以通过ES5的Object.keys(myObject)获取对象的实例属性组成的数组，不包括原型方法和属性。 for of 用来遍历数组的值]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中scroll的用法]]></title>
    <url>%2F2017%2F06%2F23%2F2017-06-23-vue-scroll%2F</url>
    <content type="text"><![CDATA[12345678910111213141516data () &#123; return &#123; scrolled: false &#125;;&#125;,methods: &#123; handleScroll () &#123; this.scrolled = window.scrollY &gt; 0; &#125;&#125;,created () &#123; window.addEventListener('scroll', this.handleScroll);&#125;,destroyed () &#123; window.removeEventListener('scroll', this.handleScroll);&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程之尾调用]]></title>
    <url>%2F2017%2F06%2F01%2F2017-06-01-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%B0%BE%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[尾调用，就是在函数的最后一步调用另一个函数123function foo(x) &#123; return g(x);&#125; 尾调用不一定出现在函数尾部，只要是最后一步操作就行 123456function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 函数m和n都属于尾调用，他们都是函数的最后一步操作 尾调用优化函数调用会在内存形成一个’调用记录‘，保存调用位置和内部变量等信息，如果在A函数中调用B函数，在A函数的调用记录上还会形成一个B的调用记录，等到B函数运行结束后，把结果返回到A，B的调用记录才会消失。如果函数B内部还调用C函数，那就是还有一个C的调用记录栈，以此类推，所有的调用记录，就会形成一个’调用栈‘。 尾调用在于它特殊的调用位置。由于是函数最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置和内部变量都不会再用到了。 ’尾调用优化‘，只调用内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-redux]]></title>
    <url>%2F2017%2F05%2F24%2F2017-05-24-react-redux%2F</url>
    <content type="text"><![CDATA[reduxredux的三个概念: action reducer store action: 一个包含type的object, 通常把一个返回action对象的函数称为action函数, 直接简称为action 1234567function action(data) &#123; return &#123; type: 'Action1', data, &#125;;&#125; reducer: 一个根据action type来更新数据的函数 123456789101112131415function reducer(state = &#123; data: 1 &#125;, action) &#123; switch (action.type) &#123; case 'action1': &#123; const newState = JSON.parse(JSON.stringify(state)); return newState; &#125; case 'action2': &#123; const newState = JSON.parse(JSON.stringify(state)); return newState; &#125; default: &#123; return state; &#125; &#125;&#125; store: 使用createStore从reducer函数创建的数据对象, 包含getState和dispatch方法 1234567import &#123; createStore &#125; from 'redux';let store = createStore(reducer);console.log(store.getState())store.dispatch(action(0))console.log(store.getState()) 注意! 更新数据需要dispatch对应的action react-redux用于将redux于react结合 Provider: 顶层组件, 注入store对象 12345678import &#123; Provider &#125; from 'react-redux';ReactDom.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('app'),); connect: 工具函数, 参数一为函数, 该函数接收state, 返回一个对象, 对象包含一系列数据. 参数二为函数, 该函数接收dispatch, 返回一个对象, 对象包含一系列方法123456789101112131415161718192021222324252627import &#123; connect &#125; from 'react-redux'; class App extends Component &#123; componentDidMount() &#123; this.props.dispatch(&#123; type: 'action1', data: 1, &#125;); &#125; render() &#123; // this.props.func1(); // this.props.func2(); return ( &lt;div&gt; &lt;/div &gt; ); &#125;&#125;export default connect( state =&gt; (&#123; data: state.data, obj: state.obj, &#125;), dispatch =&gt; (&#123; dispatch &#125;),)(App); immutable.js特殊的object(MAP)/array(LIST) 更新数据: set setIn update updateIn 读取数据: get getIn 可以直接比较(深层比较) 创建(fromJS), 还原(toJS) 123456789101112131415上述的reducer可以用下面的代码优化function reducer(state = immutable.fromJS(&#123; data: 1, obj: &#123; aa: 1 &#125; &#125;), action) &#123; switch (action.type) &#123; case 'action1': &#123; return state.set('data', action.data * 10); &#125; case 'action2': &#123; return state.setIn(['obj', 'aa'], action.data); &#125; default: &#123; return state; &#125; &#125;&#125; 优点 无需深复制, 更新数据自动返回一个新对象 适合与react shouldComponentUpdate结合来优化性能 pure-render-decorator自动创建shouldComponentUpdate的工具, 需要配置babel decorator特性才能使用]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue全家桶+crawler+koa2 实现阴阳师小助手]]></title>
    <url>%2F2017%2F05%2F20%2F2017-5-20-vue%E5%85%A8%E5%AE%B6%E6%A1%B6-crawler-koa2-%E5%AE%9E%E7%8E%B0%E9%98%B4%E9%98%B3%E5%B8%88%E5%B0%8F%E5%8A%A9%E6%89%8B%2F</url>
    <content type="text"><![CDATA[最近一直在玩阴阳师，看了好多小助手，觉得太复杂了，还得登录什么的，想着自己写一个简单的小助手，只要输入要搜索的式神，我想知道的关于这个式神的数据就能显示出来。只是第一版，前端用vue全家桶实现的，很适合刚开始接触vue的，后端用node实现的，如果有更好的建议或者想一起合作写个更好用点的，欢迎联系 作者。 yys-fe(阴阳师小助手前端) A Vue.js project github项目链接 阴阳师小助手后端实现 nodejs + crawler + koa2 + mongoose 效果图 基本- 构建工具：webpack； - 语言：Es6； - 代码规范：eslint - 应用：vue， vuex（数据管理架构）， vue-router（路由）， mint-ui（ul组件）， vue-axios（vue做的ajax请求） 目录结构1234567891011121314151617|-- [build] //构建服务和webpack配置|-- [config] //项目不同环境的配置|-- [dist] //文件服务器根目录 |-- [node_modules] //项目依赖|-- [src] //源码| |-- [assets] //资源文件| |-- [components] //项目模块文件夹| |-- [store] //存储数据| | |-- index.js //vuex store 定义| |-- App.vue //主页面 | |-- main.js //webpack预编译入口| |-- [router] //全局路由定义|-- .babelrc //babel配置|-- .eslintrc.js //eslint rule 定义|-- index.html //项目入口文件|-- package.json //项目配置文件|-- README.md //关于启动项目的命令和含义 已经完成的模块 式神搜索页面(支持模糊搜索) 式神搜索结果页面 式神列表页面 式神详细信息页面 [X] 推荐御魂 [X] 推荐搭配 [X] 式神点评 待完成与优化 搜索功能添加历史搜索和热门搜索 式神攻略 式神视频 页面样式的优化 Build Setup``` bash install dependenciesnpm install serve with hot reload at localhost:8080npm run dev build for production with minificationnpm run build 关于用vue时遇到的坑，记录在我的博客,希望可以对大家有用目前小编在学react，所以用react也写了一版,所以刚开始接触react的童鞋也可以看一下，想着第二版的ui设计的好看一点儿，功能再多一点儿，期待更多的建议。 Aboutaboutmegithubblog]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2017%2F05%2F03%2F2017-05-03-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。 排序算法 冒泡算法 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 12345678910111213function bubbleSort(arr) &#123; for(let i = 0; i &lt; arr.length; i++) &#123; for (var j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;console.log(bubbleSort([1,23,4,3])); 快速排序,通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 1234567891011121314151617function quickSort(arr) &#123; if(arr.length &lt;= 1) &#123; return arr; &#125; let leftArr = []; let rightArr = []; let q = arr[0]; for(let i = 1; i&lt;arr.length;i++) &#123; if(arr[i] &gt; q) &#123; rightArr.push(arr[i]); &#125; else &#123; leftArr.push(arr[i]); &#125; &#125; return [].concat(quickSort(leftArr),[q],quickSort(rightArr));&#125;console.log(quickSort([1,23,4,3]));]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端拿高薪必看面试题]]></title>
    <url>%2F2017%2F05%2F02%2F2017-05-02-js%E7%BB%8F%E5%85%B8%E7%AC%94%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[面试之前都会从网上找很多面试题来看,尤其是看到经典面试题,及必会的面试题,都是好好的看上几遍(其实更多的时候都是在背),可是总感觉面试之前看题作用并不大,因为你不理解的问题,还是会不理解,面试管随便一问,就不行了.其实面试几次后就会发现,经常问的问题也就那几个,比如,闭包,原型链,this,等.刚开始的时候真的是理解不了,然后就看书,强烈推荐《javascript高级程序设计(第三版)》以及《你不知道的javascript系列》,在实际项目中遇到坑的时候,就反复看,看的时候很难受,但是当真正理解了之后,就会恍然大悟,所以功夫还是下在平时,临时抱佛脚真的没啥用~ 以下是我总结的面试题中常问到的,很多都是我亲身经历的面试中遇到的一些问题,刚开始遇到的时候也不是太清楚,面试完之后就深入的学习了一下相关的知识😜 1,考察this 1234567891011121314var length = 10;function fn() &#123; console.log(this.length);&#125;var obj = &#123; length: 5, method: function(fn) &#123; fn(); arguments[0](); &#125;&#125;;obj.method(fn, 1); 10 ，2 第一次输出10应该没有问题。我们知道取对象属于除了点操作符还可以用中括号，所以第二次执行时相当于arguments调用方法，this指向arguments，而这里传了两个参数，故输出arguments长度为2。 123456789101112131415var length = 10;function fn() &#123; console.log(this.length);&#125;var obj = &#123; length: 5, method: function(fn) &#123; fn(); const fun = arguments[0]; fun()； &#125;&#125;;obj.method(fn, 1); 10 102,var和函数的提前声明 12345678function fn(a) &#123; console.log(a); var a = 2; function a() &#123;&#125; console.log(a); &#125;fn(1); function a() {} 2 var和function是会提前声明的.而且function是优先于var声明的(如果同时存在的话),所以刚开始输出的就是一个funciton,接着往下执行a进行重新赋值了,故第二次输出的是2； 3，局部变量和全局变量1234567891011121314var f = true;if (f === true) &#123; var a = 10;&#125;function fn() &#123; var b = 20; c = 30;&#125;fn();console.log(a);console.log(b);console.log(c); 输出 10 报错 30 这是个我犯了很久的错误，很长一段时间我都以为{…}内的新声明的变量是局部变量，后来我才发现function内的新声明的变量才是局部变量，而没有用var声明的变量在哪里都是全局变量。再次提醒切记只有function(){}内新声明的才能是局部变量，while{…}、if{…}、for(..) 之内的都是全局变量（除非本身包含在function内）。 4，变量隐式声明1234if( 'a' in window) &#123; var a = 10;&#125;console.log(a); 10 funciton和var会提前声明,而其实{…}内的变量也会提前声明，于是代码还没执行前a已经被声明了。所以 ‘a’ in window会返回true,a被赋值 5，给基本类型数据添加属性，不报错，但取值时是undefined1234567var a = 10;a.pro = 10;console.log(a.pro + a);var s = 'hello';s.pro = 'world';console.log(s.pro + s); NaN undefinedhello 给基本类型数据加属性不报错，但是引用的话返回undefined,10+undefined返回NaN,而undefined和string相加时转变成了字符串 6，函数声明优先于变量声明123console.log(typeof fn);function fn() &#123;&#125;;var fn; function 因为函数声明优于变量声明。我们知道在代码逐行执行前，函数声明和变量声明会提前进行，而函数声明又会优于变量声明，这里的优于可以理解为晚于变量声明后，如果函数名和变量名相同，函数声明就能覆盖变量声明。所以以上代码将函数声明和变量声明调换顺序还是一样结果。 7,判断一个字符串中出现次数最多的字符，并统计次数1234567891011121314151617181920var s = 'aaabbbcccaaabbbaaa';var obj = &#123;&#125;;var letter;var maxn = -1;for (let i = 0; i&lt; s.length; i++) &#123; if(obj[s[i]]) &#123; obj[s[i]] ++; if(obj[s[i]] &gt; maxn) &#123; maxn = obj[s[i]]; letter = s[i]; &#125; &#125; else &#123; obj[s[i]] = 1; if(obj[s[i]] &gt; maxn) &#123; maxn = obj[s[i]]; letter = s[i]; &#125; &#125; &#125;console.log(`$&#123;letter&#125;:$&#123;maxn&#125;`); 正则12345678910var s = 'aaabbbcccaaabbbaaa';var a = s.split('');a.sort();s = a.join('');var pattern = /(\w)\1*/g;var ans = s.match(pattern);ans.sort(function(a, b) &#123; return a.length &lt; b.length;&#125;)console.log(ans[0][0] + ':' + ans[0].length); 8， 经典闭包123456789101112131415161718192021222324252627282930&lt;!--html--&gt;&lt;ul&gt; &lt;li&gt;这是第1个&lt;/li&gt; &lt;li&gt;这是第2个&lt;/li&gt; &lt;li&gt;这是第3个&lt;/li&gt; &lt;li&gt;这是第4个&lt;/li&gt;&lt;/ul&gt;&lt;!--js--&gt;一：for(var i = 0; i &lt; lis.length; i++) &#123; lis[i].index = i; lis[i].onclick = function() &#123; alert(this.index); &#125;;&#125;二:for(var i = 0; i &lt; lis.length; i++) &#123; (function(i) &#123; lis[i].onclick = function() &#123; alert(i); &#125;; &#125;)(i); &#125;三：for(let i = 0; i &lt; lis.length; i++) &#123; lis[i].onclick = function() &#123; alert(i); &#125;;&#125; 从0开始隔10s按顺序出现’第一次出现’,’第二次出现’,’第三次出现‘123456789101112131415const datas = ['1', '2', '3'];let timer = null;for (let i = 0; i &lt; datas.length; i++) &#123; // const index = i; if (timer) &#123; clearTimeout(timer); let timer = setTimeout(function () &#123; console.log(datas[i]); &#125;, 10000 * i) &#125; else &#123; let timer = setTimeout(function () &#123; console.log(datas[i]); &#125;, 10000 * i) &#125;&#125;; 9，请编写一个JavaScript函数 parseQueryString，它的用途是把URL参数解析为一个对象，如： var url = “http://witmax.cn/index.php?key0=0&amp;key1=1&amp;key2=2″1234567891011121314function parseQueryString(url) &#123; var obj = &#123;&#125;; var a = url.split('?'); if(a.length === 1) return obj; var b = a[1].split('&amp;'); for(var i = 0, length = b.length; i &lt; length; i++) &#123; var c = b[i].split('='); obj[c[0]] = c[1]; &#125; return obj;&#125;var url = 'http://witmax.cn/index.php?key0=0&amp;key1=1&amp;key2=2';var obj = parseQueryString(url);console.log(obj.key0, obj.key1, obj.key2); // 0 1 2 10,this1234567891011var baz=3;var bazz=&#123; baz: 2, getbaz: function() &#123; return this.baz &#125;&#125;console.log(bazz.getbaz())var g=bazz.getbaz;console.log(g());第一个输出2，第二个输出3,函数作为对象本身属性调用的时候this指向对象，作为普通函数调用的时候就指向全局了 11，数组方法 数组排序:写一个js函数,将数组对象按照一定的顺序进行排序，且可通过参数决定升降序 123456789101112131415161718192021222324const list = [ &#123; "name": "first", "index": 1, &#125;, &#123; "name": "second", "index": 2, &#125;, &#123; "name": "third", "index": 3, &#125;, &#123; "name": "fourth", "index": 4, &#125;,]function compare(property)&#123; return function(a,b)&#123; return a[property] - a[property]; &#125;&#125;console.log(list.sort(compare('index'))) 12,求一个字符串的字节长度12345678910111213function GetBytes(str)&#123; var len = str.length; var bytes = len; for(var i=0; i&lt;len; i++)&#123; if (str.charCodeAt(i) &gt; 255) bytes++; &#125; return bytes; &#125;alert(GetBytes("你好,as"));str = 'hello world';console.log(str.charCodeAt(0)); // 104, 返回指定索引处字符的 Unicode 数值,大于255为中文console.log(str.charAt(0)); // h, 返回指定位置的字符, 13 jsonp原理及过程 利用标签没有跨域限制的“漏洞”（历史遗迹啊）来达到与第三方通讯的目的。 当需要通讯时，本站脚本创建一个元素，地址指向第三方的API网址，形如 并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如：callback({“name”:”hax”,”gender”:”Male”})这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。 14, link和@import区别 link属于html标签，而@import是css提供的。 页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。 link是html标签，因此没有兼容性，而@import只有IE5以上才能识别。 link方式样式的权重高于@import的 15,一个页面从输入url到页面加载显示完成,这个过程都发生了什么? 1,浏览器开启一个线程来处理这个请求 2,查找浏览器缓存(浏览器缓存-系统缓存-路由器缓存) 3,DNS解析,查找该域名对应的IP地址,重定向(301), 4,向真实IP地址服务器发出tcp连接,tcp三次握手 5,握手成功后,进行http协议会话,浏览器发送报头 6,进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器; 7,进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理; 8,处理结束回馈报头，将数据返回至浏览器; 9,浏览器开始下载html文档(响应报头，状态码200)，同时设置缓存; 10,之后浏览器对整个 HTML 结构进行解析，形成 DOM 树；与此同时，它还需要对相应的 CSS 文件进行解析，形成 CSS 树（CSSOM）。 11,得到绘制树之后，需要计算每个结点在页面中的位置，这一个过程称为layout 浏览器这边做的工作大致分为以下几步：加载：根据请求的URL进行域名解析，向服务器发起请求，接收文件（HTML、JS、CSS、图象等）。解析：对加载到的资源（HTML、JS、CSS等）进行语法解析，建议相应的内部数据结构（比如HTML的DOM树，JS的（对象）属性表，CSS的样式规则等等） 16,TCP传输的三次握手四次挥手策略 三次握手 SYN和ACK 发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。 四次挥手 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。17, new操作符到底干了什么?深入了解 1,创建一个空对象,而且this变量引用该对象,同时还继承了该函数的原型. 2,属性和方法被加入到this引用的对象中, 3,新创建的对象由this所引用,而且最后隐式的返回this18, null和undefined的区别? undefined (1)变量被声明了,但是没有赋值,就等于undefined (2)调用函数时,应该提供的参数没有提供,该参数等于undefined (3)对象没有赋值的属性,该属性的值为undefined (4)函数没有返回值时,默认返回undefinednull (1)作为函数的参数,表示该函数的参数不是对象 (2)作为对象原型链的终点 19, js的基本数据类型Number,String,Boolean,Null, Undefined,Object,Symbol 20,DOM怎样添加,移除,复制,和创建节点12345678910111213// 创建新节点createDocumentFragment(); // 创建一个DOM片段createElement(); // 创建一个具体的元素createTextNode(); // 创建一个文本节点//添加,移除,替换appendChild()removeChild()replaceChild()insertBefore() // 在已有的子节点前插入一个新的子节点// 查找getElementByTagName() // 通过标签名称getElementByName() // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)getElementById() // 通过元素ID,唯一性 参考总结这10道javaScript笔试题你都会么正则2016年十家公司面试小记浅谈javascript的函数节流面试题1面试题2面试题3html与css道阻且长啊TAT(前端面试总结),17年春招面试总结 Aboutaboutmegithubblog]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于斐波那契数列]]></title>
    <url>%2F2017%2F04%2F09%2F2017-04-09-%E5%85%B3%E4%BA%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[用js实现斐波那契数列首先介绍一下，斐波那契数列(Fibonacci sequence)又称黄金分割数列，斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=1，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用， 斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368…….. 这个数列从第3项开始，每一项都等于前两项之和。 实现方法一 1234567891011121314function fib(n) &#123; if(n === 0) &#123; return 0; &#125; else if(n ===1) &#123; return 1; &#125; else &#123; return fib(n-1)+fib(n-2); &#125;&#125;以上的发法是能想到的最直观的实现，现在我们测试一下他的运行结果。fib(1);fib(10)fib(50);运行发现n=1时，会快速输出1，n=10,时，运行速度稍慢，但是当n=10时，运行就非常慢，原因是什么呢，因为n=50时，要进行差不多50次的函数调用，每次调用，都会重新走if的那三个判断条件，而且每次都是从最开始开始计算，当n越大时，性能越差，所以有没有更好的方法来实现它呢？ 实现方法二1234567891011121314151617function fib(n) &#123; if(n === 0) &#123; return 0; &#125; else if(n ===1) &#123; return 1; &#125; else &#123; let a = 0, b = 1; let current = null; for(let i = 2; i &lt;= n; i++) &#123; current = b + a; a = b; b = current; &#125; return current; &#125;&#125;方法二与方法一不同之处在于，最后一个判断加入了一个for循环，current = b + a;当前享等于前两项的和，a = b;把前一项的值赋给a(第前两项)，b = current;把当前值赋给前b(第前一项)，这样当n&gt;1时，只需要在第三个判断走一个循环可以，而不需要一直调用函数，这样做比方法一性能上优化了很多，但是还有没有更好的方法呢? 实现方法三1234567891011121314151617181920212223var cache = &#123; 0: 0, 1: 1&#125;;function fib(n) &#123; return typeof cache[n] === 'number' ? cache[n] : cache[n] = fib(n - 1) + fib(n - 2);&#125;该方法的实现利用了缓存，这样每次计算的时候，都会把计算出的值存放到cache这个缓存中，等下次传入较大的n时，如果缓存中有需要的值，则直接用缓存中的值，这种方法大大提高了函数的性能。还存在一个问题,fib(10000) = Infinity;这有是为什么呢，我们可以从js中数值的取值范围考虑，如何知道js中数值的范围呢， console.log(Number.MAX_VALUE, Number.MIN_VALUE); //取得最大和最小的数console.log(Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);取得最大和最小的整数1.7976931348623157e+308 5e-3249007199254740991 -9007199254740991console.log(fib(400));console.log(fib(500));1.760236806450138e+831.394232245616977e+104n 在大于500的时候差不多已超出范围 如果有更好的方法，欢迎指正]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
