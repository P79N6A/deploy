<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[html代码实现一些符号]]></title>
    <url>%2F2017%2F11%2F22%2Fhtml%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%BA%9B%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[整理常用的一些html特殊符号在写html的时候经常会遇到一些特殊符号,例如&gt;等,大家都知道直接写&lt;或者&gt;等代码会报错,原因是因为&lt;div&gt;&lt;/div&gt;,标签是用这个符号的,代码执行的时候会以为你只写了一半,所以报错,今天就整理一写这些特殊符号用html怎么表示 html符号 特殊符号 含义 &amp;lt; &lt; 小于或显示标记 &amp;gt; &gt; 大于或者显示标记 &amp;amp; &amp; 用于显示其他特殊字符 &amp;quot; &quot; 引号 &amp;reg; &reg; 已注册 &amp;copy; &copy; 版权 &amp;trade; &trade; 商标 参考HTML特殊字符编码对照表]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请看我漂亮的坚持]]></title>
    <url>%2F2017%2F11%2F21%2F2017-11-21%2F</url>
    <content type="text"><![CDATA[今天是2017年11月21日,一周年纪念~ 今天是2017年11月21日,嘿嘿,说的是一周年纪念不是爱情的纪念,因为去年的今天我入职第一家公司,从此开始了程序媛的生活~ 记得2016年11月21日是个周一.那天下着雪,在经过一个多星期的奔波,还清晰的记得那会每天奔波的北京的各个地方,面试,很多时候,一天安排两个面试,而两个面试地点距离非常远,那会每天基本都没时间吃饭,一个星期,瘦了差不多10斤,晚上回来的时候就随便在路边买点吃的,整理今天一天面试中被问到的问题,没有回答上来或者回答不好的地方,就去网上查资料,看书查.珍惜每一次面试机会,终于找到了一家肯接受我的公司,周日那天,整整睡了一天,记得那天醒来就下午三点多了吧.入职后的每一天都小心翼翼的,因为没有经验,遇到很多问题,经常加班到晚上11点才回来,然后晚上回来还要写代码到一两点,刚来北京那会,没有钱,租的那种500块钱一个人的床位,每天回来的时候大家都已经睡着了,小心翼翼的开开门,此时别人的一个转身我都害怕是被自己吵醒的,然后洗漱完,在床位上打开电脑,把屏幕调到最暗,开始解决今天遇到的在有道云笔记上记录的问题,实在太困了,就睡;那时,就是一个想法,好好干,别被开除了,还年轻,吃点苦算什么.累的时候就会跟自己对话,当初为什么要选择这一行,不是计算机专业出身,决定从事这一行业的时候,就想到要比别人付出更多才能补回来自己缺的一些东西. 记得当时还犯了一个很严重的错误,虽然只是写写静态页面,但是写了一个星期之后,技术老大(虽然当时研发只有他和我)发现我写的代码不兼容,我能看出他看着我很无奈的样子,我立马承认自己的错误,并给他保证不用重新写,是可以改好的,自己就主动申请加班,内心里想着不要开除我就好. 后来开始做移动端,技术老大说不然咱们就试试比较流行的框架,react , vue, angular,记得当时angular还是1.0,选技术栈的过程比较曲折,终于最后选择了vue,不知道有多少人和我又一样的感受,之前一直写jq,一下子换成vue,首先思考问题的角度都要转换一下,jq是直接操作DON的,但是vue不是.印象深刻的还有,当时记得写了两个星期vue,遇到很多问题,比如路由怎么实现,等等,技术老大说,咱们能hold住新技术么,不行就换回jq,我说:现在社区这么活跃,你遇到的问题大家都遇到过,肯定是可以解决的.真的很感谢,给我机会去尝试新技术. 也许是骨子里带着一股不服输的精神,坚持一直学,天道酬勤,终于后来慢慢在公司里有点权威,最起码,产品提的需求,别人实现不了,我可以实现.就是这样慢慢建立起了自信,经过自己的努力实现的那种成就感,很爽! 到今天整整一年了,技术上相比去年也增长了很多,大概在今年夏天的时候开始写自己的博客,在简书上发表文章,看到下面有人给我评论,和我交流技术,真的很开心,看到很多人通过博客加我好友,支持我,鼓励我,给我提建议,还有前几天第一次在掘金上发表文章,很多人给我点赞,还有大佬给我提建议,真的发自内心的感谢! 这一年接触了很多东西,写过vue,react,koa,玩过小程序,现在在用Meteor+react+mongoDB写全栈,但是对于具体的原理了解的可能还不是很深入,所以接下来一年,我给自己制定的目标,学好js的基础,在此基础上学一些主流框架原理上的一些东西,还有目前实现产品提的需求已经不是什么大的问题了,问题是如果写好,比如代码的组织和性能等,总之路漫漫其兮远,慢慢一步一步脚踏实地的来. 大概就写到这儿吧,看到这篇文章的有缘人,不知道你是否和我一样也有这些经历,不过,肯定是和我一样希望让自己变得更优秀的人,只要用心学习,付出努力,技术肯定是会慢慢提高的. 给大家推荐几本书: Javascript高级程序设计(3),(记得我看的是第三版,或者权威指南,讲的js的知识特别全) 你不知道的JavaScript系列(深入的讲解javascript) 深入理解es6 深入浅出react技术栈 图解http 大话设计模式 NodeJs实战]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两句话理解js中的this]]></title>
    <url>%2F2017%2F11%2F16%2Fthis%2F</url>
    <content type="text"><![CDATA[前言: 一直都搞不清javascript中this的指向,&lt;你不知道的javascript(上卷)&gt;这本书中有3章都是在讲解this,去年第一次看完还是觉得似懂非懂的,一深入的问还是不清楚,现在在看一遍,真心觉得这本书里将的是真好,想深入了解一下的,这本书是一个不错的选择. 下面我就简单的说一下我的理解,用两句话记住了javascrpt中this的指向: this的指向 普通函数指向函数的调用者:有个简便的方法就是看函数前面有没有点,如果有点,那么就指向点前面的那个值; 箭头函数指向函数所在的所用域: 注意理解作用域,只有函数的{}构成作用域,对象的{}以及 if(){}都不构成作用域; 12345678910111213// const obj = &#123; name: 'objName', say() &#123; console.log(this.name); &#125;, read: () =&gt; &#123; console.log(this.name); &#125;&#125;obj.say(); // objNameobj.read(); // undefined 普通函数,调用者是obj,所以结果是 objname;也是理解say()是普通函数,前面有点,所以this指向obj; 箭头函数,this指向函数所在的作用域,当前的作用域为全局环境,所以this.name为undefined, 举下面的例子更清楚的了解一下箭头函数this的指向,箭头函数所在的作用域是普通函数say,say()的调用者是obj12345678const obj = &#123; say: function () &#123; setTimeout(() =&gt; &#123; console.log(this) &#125;); &#125;&#125;obj.say(); // obj,此时this指的是定义他的obj 补充知识点 浏览器默认的this为window 1234function test() &#123; console.log(this);&#125;test(); //window node.js中全局环境默认this为{},普通函数中默认this为global 123456console.log(this); // &#123;&#125;function test() &#123; console.log(this);&#125;test(); //global 来两道题检查你是否掌握了example11234567891011121314const length = 10;function fn() &#123; console.log(this.length);&#125;const obj = &#123; length: 5, method: function(fn) &#123; fn(); arguments[0](); &#125;&#125;;obj.method(fn, 1); 输出 10, 2 刚开始看到这道题我也是蒙蒙的,现在也终于理解了,method这个函数传入了两个参数,一个参数为fn(),fn()为普通函数,this指向函数的调用者,此时指向全局(也可以看这个函数前面没有点),所以运行结果为10,arguments是函数的所有参数,是一个类数组的对象,arguments0,可以看成是arguments.0(),调用这个函数的是arguments,此时this就是指arguments,this.length就是angument.length,就是传入的参数的总个数2 注: 上面例子在node环境中的运行结果为 undefined 2, const length = 10改成global.length = 10;是因为node环境下定义在全局的变量不会绑定到global,浏览器也会自动绑定到全局环境window 改成下面这样结果又是什么呢?12345678910111213141516const length = 10;function fn() &#123; console.log(this.length);&#125;const obj = &#123; length: 5, method: function(fn) &#123; fn(); const fun = arguments[0]; fun()； &#125;&#125;;obj.method(fn, 1); 10, 10 example 212345678910111213window.val = 1;var obj = &#123; val: 2, dbl: function() &#123; this.val *= 2; val *= 2; console.log(val); console.log(this.val); &#125;&#125;obj.dbl(); // 2 4var func = obj.dbl;func(); // 8 8 这个就是有点绕了,不过一步步来分析就很容易理解了: obj.dbl();执行这行代码时，this指的是obj，所以this.val === obj.val*=2,最后结果为4,val*=2 === window.val *= 2，最后结果是2 func()，执行这行代码时，func()没有任何前缀，this指的是window.func();所以此时this值得是window，this.val === window.val *= 2,此时window.val 为4，val*=2 === window.val *2,最后结果为8，最后console.log(this.val),与console.log(val),指的都是window.val，最后结果都是8]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探React生命周期]]></title>
    <url>%2F2017%2F11%2F14%2F%E5%88%9D%E6%8E%A2React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[react生命周期挂载和卸载过程1,组件挂载是最基本的过程,这个过程主要做组件状态的初始化.12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; Component &#125; from 'react';import PropTypes from 'prop-types';class App extends Component &#123; // 1,这两个属性被声明成静态属性,意味着你也可以再类外面访问他们: App.propTypes和 App.defaultProps static propTypes = &#123; // props的类型检查 &#125; static defaultProps = &#123; // props的默认类型 &#125; constructor(props) &#123; super(props); this.state = &#123; // &#125; &#125; // 2,componentWillMount和componentDidMount分别代表了渲染前后的时刻 componentWillMount() &#123; // 在render方法之前执行 &#125; componentDidMount() &#123; //render方法之后执行 &#125; // 3,这个初始化过程没什么特别的,包括读取初始state和props以及这两个生命周期的方法componentWillMount和componentDidMount,这些都只会在组件初始化时运行一次 // 4,如果我们在componentWillMount中执行setState方法,会发生什么呢?组件会更新state,但是组件只渲染一次,初始化的state都可以放在this.state // 5,我们在componentDidMount中执行setState方法,又会发生什么呢?组件当然会再次更新,不过在初始化阶段就渲染了两次,这并不是一件好事. // 但是实际的情况是,有一些场景不得不需要setState,比如计算组件的宽高时,就不得不让组件先渲染,更新必要的信息,再次渲染 componentWillUnmount() &#123; // 组件卸载只有componentWillUnmount,这是一个卸载前状态 // 在这个方法中,我们常常会执行一些清理方法,如事件回收或是清理定时器 &#125; render() &#123; return ( &lt;div&gt; this is demo &lt;/div&gt; ); &#125;&#125;export default App; 数据更新过程12345678910111213141516171819202122232425262728import React, &#123; Component &#125; from 'react';import PropTypes from 'prop-types';class App extends Component &#123; componentWillReceiveProps(nextProps) &#123; // this.setState(&#123;&#125;) &#125; shouldComponentUpdate(nextProps, nextState) &#123; // return true // shouldComponentUpdate是一个特别的方法,他接受需要更新的props和state,让开发者增加必要的条件判断,让其在需要时更新.因此,当方法返回false的时候,组件不再向下执行生命周期方法 &#125; componentWillUpdate(nextProps, nextState) &#123; // 需要提供更新的props和state // 这里不能执行setState &#125; componentDidUpdate(prevProps, prevState) &#123; // 提供更新前的props和state &#125; render() &#123; return ( &lt;div&gt; this is demo &lt;/div&gt; ); &#125;&#125;export default App; 如果组件自身的state更新了,那么会依次执行shouldComponentUpdate,componentWillUpdate,render, componentDidUpdate. shouldComponentUpdate是一个特别的方法,他接受需要更新的props和state,让开发者增加必要的条件判断,让其在需要时更新.因此,当方法返回false的时候,组件不再向下执行生命周期方法 本质是用来进行正确的组件渲染(也是性能优化的手段之一): 当父节点props改变的时候,在理想情况下,只渲染在一条链路省有相关props改变的节点即可,但是默认情况下,React会渲染所有的节点,因为shouldComponentUpdate默认返回true 值得注意的是,无状态组件是没有生命周期方法的,这也意味着它没有shouldComponentUpdate,渲染到该类组件时,每次都会重新渲染,不少开发者在使用无状态组件开发的时候都会纠结这一点,为了更方心得使用,我们可以选择用Recompose库的pure方法; const optionmizeComponent = pure(ExpensiveComponent) pure方法做的事情就是将无状态组件转换成class语法加上PureRender后的组件 如果组件是由父组件更新props而更新的,那么在shouldComponentUpdate之前会先执行componentWillReceiveProps方法,此方法可以作为React在props传入后,渲染之前setState的机会,在此方法中调用setState是不会二次渲染的 整体流程React的生命周期流程我们用一张图来表示 Aboutgithubblog]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解git系列]]></title>
    <url>%2F2017%2F11%2F02%2Fgit%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[文章参考: http://git.oschina.net/progit/ 1,git简介版本控制简而言之,就是可以报存你所有的修改,所有的历史版本;有了它,就可以将某个文件回溯到之前的状态,甚至可以将整个项目回退到过去某个时间点的状态;你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等 类别集中化的版本控制系统(eg: svn) 分布式版本控制系统(eg: git) 文件的三种状态对于任何一个文件，在 Git 内都只有三种状态： 已提交（committed），已提交表示该文件已经被安全地保存在本地数据库中了； 已修改（modified,已修改表示修改了某个文件，但还没有提交保存； 已暂存（staged）。已暂存表示把已修改的文件放在下次提交时要保存的清单中。git管理项目时,文件流转的三个工作区域:git的工作目录,暂存区域,本地仓库 每个项目都有一个Git目录(如果 git clone 出来的话，就是其中 .git 的目录) 从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录 所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中 2,git基础取得项目的Git仓库有两种方法:1,在现存的目录下,通过导入所有文件来创建新的Git仓库;2,从已有的Git仓库克隆出一个新的镜像仓库 在工作目录中初始化新仓库 123git init // 初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中git add README // 如果当前目录下有几个文件想要纳入版本控制,需要先用`git add`命令告诉git开始对这些文件进行跟踪,并进行提交git commit -m 'initial project version' 从现有仓库克隆克隆仓库的命令格式为 git clone [url]。比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令： 1git clone git://github.com/schacon/grit.git 当前目录下创建一个名为grit的目录,其中包含一个.git的目录用于保存下载下来的所有版本记录,然后从中取出最新版本的文件拷贝如果希望在git clone的时候,自己定义要新建的项目目录的名称,可以再上面的命令的末尾指定新的名字1git clone git://github.com/schacon/grit.git mygrit 现在新建的目录就成了mygrit 文件状态git status 可以查看文件目前处于什么状态git add xx 这是一个多功能命,根据目标文件的状态不同,此命令的效果也不同;可以用它开始跟踪新文件,或者把已跟踪的文件放到暂存区,还能用于合并时把有冲突的文件标记为已解决状态 忽略某些文件我们可以创建一个.gitignore的文件,列出要忽略的文件模式.gitignore的格式规范如下: 所有空行或者以注释符号#开头的行都会被Git忽略 可以使用标准的glob模式匹配(shell所使用的简化了的正则表达式) 匹配模式最后跟反斜杠(/)说明要忽略的是目录 要忽略指定模式以外的文件或目录,可以再模式前加上(!)取反 1234567891011# 此为注释 – 将被 Git 忽略 # 忽略所有 .a 结尾的文件 *.a # 但 lib.a 除外 !lib.a # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO /TODO # 忽略 build/ 目录下的所有文件 build/ # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt doc/*.txt 查看已暂存和未暂存的更新12git diffgit diff --cached 提交更新12git commitgit commit -m&apos;docs: change readme&apos; // -m参数后跟提交的方式 git commit 规范参考 跳过使用暂存区域 git commit -a -m&#39;feat: add new tasks&#39;git 提供了一个跳过使用暂存区域的方式，只要在提交的时候给git commit加上-a选项，git就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add步骤1git commit -a -m&apos;feat: add new tasks&apos; 移除文件 git rm从git中移除某个文件，必须要从已跟踪文件清单移除（从暂存区域移除）,然后提交,git rm命令完成此项工作，并连带从工作目录中删除制定的文件，这样以后就不会出现在未跟踪文件清单了1git rm .test 如果是简单从工作目录中手工删除文件，仅删除了工作目录中的，仍在追踪名单中然后再运行 git rm记录此次移除文件的操作最后提交就不会被跟踪了。但是如果删除文件之前修改过且已经放到暂存区，则必须要加-f(即force的首字母)在实际项目中，经常会遇到下面的情况需要删除文件想把文件从git仓库中删除，但是仍希望保留在工作目录中，就是仅从跟踪清单中删除，比如一些大型日志或一堆.a的编译文件，不小心纳入仓库，但是要移除追踪但不删除文件，以便稍后在.gitignore文件中补上，加参数--cached1git rm --cached readme.txt 后面可以列出文件或者目录的名字，也可以使用 glob 模式。注意到星号 * 之前的反斜杠 \，因为 Git 有它自己的文件模式扩展匹配方式，12git rm log/\*.log // 此命令删除所有 log/ 目录下扩展名为 .log 的文件git rm \*~ //会递归删除当前目录及其子目录中所有 ~ 结尾的文件。必须加反斜杠 移动文件git mv1git mv file_from file_to 相当于运行123mv README.txt READMEgit rm README.txtgit add README 查看提交历史 git log123git log -p -2 // -p选项展开每次提交的内容差异， -2则仅显示最近两次更新， 做代码审查，或者快速浏览其他写作者提交的更新都做了哪些git log --stat // 仅显示简要的增改行数git log --pretty // 指定使用完全不同于默认风格的方式展示提交历史，比如`git log --pretty=oneline`将每个提示放在一行显示，另外还有short， full和fuller format，可以定制要显示的记录格式，这样的输出便于后期编程提取分析1234git log --pretty=format:&quot;%h - %an, %ar : %s&quot;ca82a6d - Scott Chacon, 11 months ago : changed the version number085bb3b - Scott Chacon, 11 months ago : removed unnecessary test codea11bef0 - Scott Chacon, 11 months ago : first commit 用 oneline 或 format 时结合 –graph 选项，可以看到开头多出一些 ASCII 字符串表示的简单图形，形象地展示了每个提交所在的分支及其分化衍合情况1234567891011$ git log --pretty=format:&quot;%h %s&quot; --graph * 2d3acf9 ignore errors from SIGCHLD on trap * 5e3ee11 Merge branch &apos;master&apos; of git://github.com/dustin/grit |\ | * 420eac9 Added a method for getting the current branch. * | 30e367c timeout code and tests * | 5a09431 add timeout protection to grit * | e1193f8 support for heads with slashes in them |/ * d6016bc require time for xmlschema * 11d191e Merge branch &apos;defunkt&apos; into local 列出了常用的格式占位符写法及其代表的意义。12345678910111213141516选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 -date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 一些其他常用的选项及其释义。12345678910选项 说明 -p 按补丁格式显示每个更新之间的差异。 --stat 显示每次更新的文件修改统计信息。 --shortstat 只显示 --stat 中最后的行数修改添加移除统计。 --name-only 仅在提交信息后显示已修改的文件清单。 --name-status 显示新增、修改、删除的文件清单。 --abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 --relative-date 使用较短的相对时间显示（比如，“2 weeks ago”）。 --graph 显示 ASCII 图形表示的分支合并历史。 --pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 限制输入长度 –since 和 –unti1234567git log --since=2.weeks // 列出所有最近两周内的提交选项 说明 -(n) 仅显示最近的 n 条提交 --since, --after 仅显示指定时间之后的提交。 --until, --before 仅显示指定时间之前的提交。 --author 仅显示指定作者相关的提交。 --committer 仅显示指定提交者相关的提交。 如果要查看 Git 仓库中，2017 年 10 月期间，Junio Hamano 提交的但未合并的测试脚本（位于项目的 t/ 目录下的文件），可以用下面的查询命令1git log --pretty=&quot;%h - %s&quot; --author=gitster --since=&quot;2008-10-01&quot; \ 撤销操作修改最后一次提交 git commit --amend123git commit -m &apos;initial commit&apos;git add forgotten_filegit commit --amend 如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 –amend 提交：上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。 取消已经暂存的文件 git reset HEAD &lt;file&gt;...有两个修改过的文件，我们想要分开提交，但不小心用 git add . 全加到了暂存区域。该如何撤消暂存其中的一个文件呢1git reset HEAD benchmarks.rb 取消对文件的修改 git checkout -- &lt;file&gt;..如果觉得刚才对 benchmarks.rb 的修改完全没有必要，该如何取消修改，回到之前的状态（也就是修改之前的版本）呢1git checkout -- benchmarks.rb 任何已经提交到 Git 的都可以被恢复。即便在已经删除的分支中的提交，或者用 –amend 重新改写的提交，都可以被恢复（关于数据恢复的内容见第九章）。所以，你可能失去的数据，仅限于没有提交过的 远程仓库的使用 查看当前的远程库 git remove -v,名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库 添加远程仓库git remote add [shortname] [url] 从远程仓库抓取数据git fetch [remote-name] 推送数据到远程仓库 git push [remote-name] [branch-name] 查看某个远程仓库信息git remote show [remote-name] 远程仓库的删除和重命名 git remote rename pb paul git remote rename rm [remote-name]1234567891011121314git remove -vgit remote add pb git://github.com/paulboone/ticgit.gitgit fetch pb // git push origin master //把本地的 master 分支推送到 origin 服务器上git remote show origin // 要看所克隆的 origin 仓库$ git remote rename pb paul $ git remote origin paulgit remote rm paul $ git remote origin git fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支,git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支 打标签 列显已有的标签 git tag 新建标签,含附注的标签 3，分支简单的分支与合并，实际工作中大体的工作流程1，开发某个网站2，为了实现某个需求，创建一个分支3，在这个分支上开展工作；假设此时，突然有个紧急的问题要修复，那么你可以按照下面的方式处理:1,返回原先已经发布到生产服务器上的分支；2，为这次紧急修补创建一个新分支，并在其中修复问题3，通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上4，切换到之前实现新需求的分支，继续工作 新建分支 新建分支 git branch xx,这条命令是新建了一个分支，但是当前工作分支仍在mater分支上，要想把当前工作分支切换到新建的分支上，要执行git checkout xx 新建并切换到某分支git checkout -b xx相当与下面这两条命令12git branch xxgit checkout xx 切换分支的时候要确保你当前分支不存在没有提交的修改，否则git会阻止你切换分支 删除分支 删除分支 git branch -d xx合并分支 分支的合并，比如master分支要合并xx分支，首先切换到master分支，然后执行git merge xx,此时xx分支已经合并到master分支上，接下来删除xx分支 123git checkout mastergit merge xxgit branch -d xx 遇到冲突时的合并，如果在不同的分支中都修改看同一个文件，git就无法将两者合并到一起 1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html &lt;div id="footer"&gt;contact : email.support@github.com&lt;/div&gt; ======= &lt;div id="footer"&gt; please contact us at support@github.com &lt;/div&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html =======隔开的上半部分，即HEAD(即master分支，在运行merge命令时所切换到的分支)，下半部分是xx分支的内容你可以二者选其一或者整合两者到一起，然后删除&lt;&lt;&lt;&lt;&lt;&lt;&lt;，======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt;这些行.解决完所有冲突后，运行git add将他们标记为已解决状态(实际就是将该文件存到暂存区，因为一旦暂存，就表示冲突已经解决) 分支的管理1234git branch // 列出当前所有分支，注意看master分支前的 * 字符：它表示当前所在的分支git branch -v // 查看各个分支最后一个提交对象的信息git branch --merged // 筛选与当前分支合并的分支git branch --no-merged // 筛选与当前分支尚未合并的分支，此时如果使用`git branch -d xx`删除该分支会提示错误，因为这样会丢失数据，如果你确实想删除该分支上的改动，运行`git branch -D xx`强制删除 利用分支开发的工作流程长期分支在master分支中保留完全稳定的代码，即已经发布或即将发布的代码，与此同时，还有一个名为develop或next的平行分支，专门用于后续的开发或仅用于稳定性测试 — 当然并不是说一定要绝对稳定，不过一旦进入某种稳定状态，便可以把它合并到 master 里。这样，在确保这些已完成的特性分支（短期分支，比如之前的 iss53 分支）能够通过所有测试，并且不会引入更多错误之后，就可以并到主干分支中，等待下一次的发布。你可以用这招维护不同层次的稳定性。某些大项目还会有个 proposed（建议）或 pu（proposed updates，建议更新）分支，它包含着那些可能还没有成熟到进入 next 或 master 的内容。这么做的目的是拥有不同层次的稳定性：当这些分支进入到更稳定的水平时，再把它们合并到更高层分支中去。 特性分支一个特性分支是指一个短期的，用来实现单一特性或与其相关工作的分支。 远程分支远程分支是对远程仓库中分支的索引。(远程仓库)/(分支名)表示远程分支 推送远程分支git push (远程仓库名) (分支名)12345678 git push origin serverfix Git 自动把 serverfix 分支名扩展为 refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”。仓库中去，仍旧称它为 servergit push origin serverfix:serverfix上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支git push origin serverfix:awesomebranch上传我本地的 serverfix 分支到远程仓库中去，称它为 awesomebranch 分支 如果要把该远程分支的内容合并到当前分支，可以运行 git merge origin/serverfix 想要基于远程分支上新建一个新的分支 git checkout -b serverfix origin/serverfix 跟踪远程分支从远程分支checkout出来的本地分支，成为跟踪分支。跟踪分支是一种和某个远程分支有直接联系的公司；克隆仓库时，git通常会自动创建一个名为master分支来跟踪origin/master;这正是 git push 和 git pull 一开始就能正常工作的原因 git checkout -b serverfix origin/serverfix 可以用 –track 简化: git checkout –track origin/serverfix 本地分支设定不同于远程分支的名字，只需在第一个版本的命令里换个名字: git checkout -b sf origin/serverfix 删除远程分支 git push [远程名] :[分支名] git push [远程名] [本地分支]:[远程分支],如果省略 [本地分支]，如果省略 [本地分支] 分支的衍合把一个分支整合到另一个分支的办法有两种: merge rebase使用衍合的目的是想要得到一个能在远程分支上干净应用的补丁,简单的说就是修改提交历史一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。12345git rebase --onto master server client取出 client 分支，找出 client 分支和 server 分支的共同祖先之后的变化，然后把它们在 master 上重演一遍”git rebase [主分支] [特性分支] 命令会先取出特性分支 server，然后在主分支 master 上重演：git rebase master server]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebRTC]]></title>
    <url>%2F2017%2F11%2F02%2FWebRTC%2F</url>
    <content type="text"><![CDATA[1,WebRTC入门基础什么是WebRTCWebRtc(Web Real-Time Communication)支持网页浏览器进行实时语音对话或视频对话的技术; 浏览器本身不支持互相之间直接建立信道进行通信,都是通过服务器进行中转.比如现在有两个客户端,甲和乙,他们俩想要通信,首先需要甲和服务器.乙和服务器之间建立信道.甲给乙发送消息时,甲先将消息发送到服务器上,服务器对家的消息进行中转,发送到乙处,反过来也是一样.这样甲和乙之间的依次消息要通过两段信道,通信的效率同时受制于这两端信道的带宽.同时这样的信道并不适合数据流的传输 WebRTC是一个开源项目，旨在使得浏览器能为实时通信（RTC）提供简单的JavaScript接口;让浏览器提供JS的即时通信接口。这个接口所创立的信道并不是像WebSocket一样，打通一个浏览器与WebSocket服务器之间的通信，而是通过一系列的信令，建立一个浏览器与浏览器之间（peer-to-peer）的信道，这个信道可以发送任何数据，而不需要经过服务器。并且WebRTC通过实现MediaStream，通过浏览器调用设备的摄像头、话筒，使得浏览器之间可以传递音频和视频 三个接口WebRTC实现了三个API,分别是: MediaStream: 通过MediaStream的API能够通过设备的摄像头及话筒获得视频,音频的同步流 RTCPeerConnection: RTCPeerConnection是WebRTC用于构建点对点之间稳定高效的流传输的组件 RTCDataChannel: RTCDataChannel使得浏览器之间(点对点)建立一个高吞吐量.低延时的信道,用于传输任意数据 MediaStream(getUserMedia)通过MediaStream的API能够通过设备的摄像头及话筒获得视频,音频的同步流 如果调用可以通过调用navigator.getUserMedia(),这个方法接受三个参数:1,一个约束对象(constrains object)2,一个调用成功的回调函数,如果调用成功,传递给他一个流对象3,一个调用失败的额回调函数,如果调用失败,传递给他一个错误对象 浏览器的兼容性1234const getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia); 约束对象可以被设置在getUserMedia()和RTCPeerConnection的 addStream方法中,这个约束对象是WebRTC用来指定接受什么样的流,其中可以定义如下属性 video: 是否接受视频流 audio: 是否接受音频流 MinWidth: 视频流最小宽度 MaxWidth: 视频流最大宽度 MinHeight: 视频流最小高度 MaxHeight: 视频流最大高度 MinAspectRatio: 视频流最小宽高比 MaxAspectRatio: 视频流最大宽高比 MinFramerate: 视频流最小帧速率 MaxFramerate: 视频流最大帧速率 例子1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;GetUserMedia实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;video id="video" autoplay&gt;&lt;/video&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt; var getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia); getUserMedia.call(navigator, &#123; video: true, audio: true &#125;, function(localMediaStream) &#123; var video = document.getElementById('video'); video.src = window.URL.createObjectURL(localMediaStream); video.onloadedmetadata = function(e) &#123; console.log("Label: " + localMediaStream.label); console.log("AudioTracks" , localMediaStream.getAudioTracks()); console.log("VideoTracks" , localMediaStream.getVideoTracks()); &#125;; &#125;, function(e) &#123; console.log('Reeeejected!', e); &#125;);&lt;/script&gt;&lt;/html&gt; 这里使用getUserMedia获得流之后,需要将其输出,一般绑定到video标签上输出,需要使用window.URL.createObjectURL(localMediaStream)来创造能在video中使用 src属性播放的Blob URL,注意在video上加入autoplay属性,否则只能扑火到一张图片流创建完毕后可以通过label属性来获得其唯一的标识，还可以通过getAudioTracks()和getVideoTracks()方法来获得流的追踪对象数组（如果没有开启某种流，它的追踪对象数组将是一个空数组） PTCPeerConnectionWebRTC使用RTCPeerConnection来在浏览器之间传递流数据,这个流数据通道是点对点的,不需要经过服务器进行中转.但是这并不意味着我们能抛弃服务器.我们仍然需要它来为我们传递信令来建立这个信道.WebRTC没有定义用于建立信道的信令的协议：信令并不是RTCPeerConnection API的一部分 信令既然没有定义具体的信令的协议，我们就可以选择任意方式（AJAX、WebSocket），采用任意的协议（SIP、XMPP）来传递信令，建立信道.比如可以用node的ws模块,在在WebSocket上传递信令需要信令来交换的信息有三种： session的信息:用来初始化通信还有报错 网络配置: 比如IP地址和端口啥的 媒体适配: 发送方和接受方的浏览器能接受什么样的编码器和分辨率 通过服务器建立信道就算WebRTC提供浏览器之间点对点信道的数据传输,但是建立这个信道,必须有服务器的参与,WebRTC需要服务器对其进行4方面的功能支持 1,用户发现以及通信 2,信令传递 3,NAT/防火墙穿越 4,如果点对点通信建立失败,可以作为中转服务器 NAT/防火墙穿越技术建立点对点信道的一个常见问题，就是NAT穿越技术。在处于使用了NAT设备的私有TCP/IP网络中的主机之间需要建立连接时需要使用NAT穿越技术。以往在VoIP领域经常会遇到这个问题。目前已经有很多NAT穿越技术，但没有一项是完美的，因为NAT的行为是非标准化的。这些技术中大多使用了一个公共服务器，这个服务使用了一个从全球任何地方都能访问得到的IP地址。在RTCPeeConnection中，使用ICE框架来保证RTCPeerConnection能实现NAT穿越 ICE，全名叫交互式连接建立（Interactive Connectivity Establishment）,一种综合性的NAT穿越技术，它是一种框架，可以整合各种NAT穿越技术如STUN、TURN（Traversal Using Relay NAT 中继NAT实现的穿透）。ICE会先使用STUN，尝试建立一个基于UDP的连接，如果失败了，就会去TCP（先尝试HTTP，然后尝试HTTPS），如果依旧失败ICE就会使用一个中继的TURN服务器。 RTCDataChannel既然能建立点对点的信道来传递实时的视频,音频数据流.为什么不你能用这个信道传一点其他数据呢?RTCDataChannel就是用来干这个的,基于它我们可以再浏览器之间传输任意数据,DataChannel是建立在PeerConnection上的,不能单独使用 我们可以使用channel = pc.createDataCHannel(“someLabel”);来在PeerConnection的实例上创建Data Channel，并给与它一个标签DataChannel使用方式几乎和WebSocket一样，有几个事件： onopen onclose onmessage onerror 同时它有几个状态，可以通过readyState获取： connecting: 浏览器之间正在试图建立channel open：建立成功，可以使用send方法发送数据了 closing：浏览器正在关闭channel closed：channel已经被关闭了两个暴露的方法: close(): 用于关闭channel send()：用于通过channel向对方发送数据 通过Data Channel发送文件大致思路JavaScript已经提供了File API从input[type=’file’]的元素中提取文件，并通过FileReader来将文件的转换成DataURL，这也意味着我们可以将DataURL分成多个碎片来通过Channel来进行文件传输 2,信令WebRTC的服务器WebRTC提供了浏览器到浏览器（点对点）之间的通信，但并不意味着WebRTC不需要服务器。暂且不说基于服务器的一些扩展业务，WebRTC至少有两件事必须要用到服务器： 浏览器之间交换建立通信的元数据（信令）必须通过服务器 为了穿越NAT和防火墙为什么需要信令我们需要通过一系列的信令来建立浏览器之间的通信.而具体需要通过信令交换哪些内容,下面简单的列了一下1,用来控制通信开启或者关闭的连接控制信息2,发生错误时用来彼此告知的信息3,媒体流元数据,比如像解码器,解码器的配置,带宽,媒体类型4,用来建立安全连接的关键数据5,外界所看到的网络上的数据,比如IP地址,端口等在建立连接之前，浏览器之间显然没有办法传递数据。所以我们需要通过服务器的中转，在浏览器之间传递这些数据，然后建立浏览器之间的点对点连接。但是WebRTC API中并没有实现这些。 会话描述协议(Session Description Protocol)JSEP将客户端之前传递的信令分为两种:offer信令和answer信令.他们主要内容的格式都遵循会话描述协议(Session Description Protocol,简称SDP)是一个在点对点连接中描述自己的字符串.我们可以将其封装在JSON中进行传输,在PeerConnection建立后将通过服务器中转后,将自己的SDP描述符和对方的SDP描述符交给PeerConnection就行了 信令与PTCPeerConnection建立1,通过offer和answer交换SDP描述符大致上在两个用户（甲和乙）之间建立点对点连接流程应该是这个样子（这里不考虑错误的情况，RTCPeerConnection简称PC）： 甲和乙各自建立一个PC实例 甲通过PC所提供的createOffer()方法建立一个包含甲的SDP描述符的offer信令 甲通过PC所提供的setLocalDescription()方法，将甲的SDP描述符交给甲的PC实例 甲将offer信令通过服务器发送给乙 乙将甲的offer信令中所包含的的SDP描述符提取出来，通过PC所提供的setRemoteDescription()方法交给乙的PC实例 乙通过PC所提供的createAnswer()方法建立一个包含乙的SDP描述符answer信令 乙通过PC所提供的setLocalDescription()方法，将乙的SDP描述符交给乙的PC实例 乙将answer信令通过服务器发送给甲 甲接收到乙的answer信令后，将其中乙的SDP描述符提取出来，调用setRemoteDescripttion()方法交给甲自己的PC实例 甲和乙所创建的PC实例都包含了甲和乙的SDP描述符,接下来–获取连接两端主机的网络地址 2,通过ICE框架建立NAT/防火墙穿越的连接123456var iceServer = &#123; "iceServers": [&#123; "url": "stun:stun.l.google.com:19302" &#125;]&#125;;var pc = new RTCPeerConnection(iceServer); 当然这两个地址也需要交换,交换流程如下(RTCPeerConnection简称PC);1,甲,乙各创建配置了ICE服务器的PC实例,并为其添加onicecandidate事件回调2,当网络候选可用时,将会调用onicecandidate函数3,在回调函数内部,甲或乙将网络候选色消息封装在ICE Candidate命令中,通过服务器中转,传递给对方4,甲或乙接收到对方通过服务器中转所发送过来ICE Candidate信令时,将其解析并并获得网络候选,将其通过PC实例的addIceCandidate()添加到PC实例中 这样连接就创建完成了,可以向RTCPeerConnection中通过addStream()加入流来传输媒体流出具.将流加入到RTCPeerConnection实例中,对方就可以通过onaddstream所绑定的回调函数监听到了,调用addStream()可以再连接完成之前,在连接建立之后,对方一样能监听到媒体流 聊天室中的信令用户操作1,打开页面连接到服务器2,进入聊天室3,与其他所有已在聊天室的用户建立点对点的连接,输入到页面4,若有聊天室内其他用户离开,得到通知,关闭与其的连接并移除其在页面中的输出5,若又有其他用户加入,应得到通知,建立与新加入用户的连接,并输出在页面上6.离开页面,关闭所有连接 实现思路以使用WebSocket为例1,浏览器与服务器建立WebSocket连接2,发送一个加入聊天室的信令(join),信令中需要包含用户所进入的聊天室名称3,服务器根据用户所加入的房阿金,发送一个其他用户信令(peers);信令中包含聊天室其他用户的信息,浏览器根据信息来逐个构建与其他用户的点对点连接4,若有用户离开,服务器发送一个用户离开信令(remove_peer),信令中包含离开的用户的信息,浏览器根据信息关闭与离开用户的信息,并作相应的清除操作5,若有新用户加入,服务器发送一个用户加入信令(new_peer),信令中包含新加入的用户信息,浏览器根据信息来建立与这个新用户的点对点连接;6,用户离开页面,关闭WebSocket连接 服务器端实现由于用户可以只是建立连接，可能还没有进入具体房间，所以首先我们需要一个容器来保存所有用户的连接，同时监听用户是否与服务器建立了WebSocket的连接：由于有房间的划分，所以我们需要在服务器上建立一个容器，用来保存房间内的用户信息。显然对象较为合适，键为房间名称，值为用户信息列表。 同时我们需要监听上面所说的用户加入房间的信令（join），新用户加入之后需要向新用户发送房间内其他用户信息（peers）和向房间内其他用户发送新用户信息（new_peer），以及用户离开时向其他用户发送离开用户的信息（remove_peer）: 参考 使用WebRTC搭建前端视频聊天室——入门篇 使用WebRTC搭建前端视频聊天室——信令篇 使用WebRTC搭建前端视频聊天室——点对点通信篇 使用WebRTC搭建前端视频聊天室——数据通道篇 使用 WebRTC 构建简单的前端视频通讯 直播和截图]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组减去另一数组(数组的每一项都是一个对象)]]></title>
    <url>%2F2017%2F10%2F21%2F%E6%95%B0%E7%BB%84%E5%87%8F%E5%8E%BB%E5%8F%A6%E4%B8%80%E6%95%B0%E7%BB%84-%E6%95%B0%E7%BB%84%E7%9A%84%E6%AF%8F%E4%B8%80%E9%A1%B9%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[做聊天项目的时候遇要实现这样的一个功能: 邀请新的好友入群;点击邀请好友会弹出一个好友列表,显示你除了在群里面的好友外剩下的所有好友;我的思路是取到你所有的好友,然后所有好友中过滤掉已经是群成员的好友 123456789101112131415161718192021222324const users = [ &#123; _id: 1, name: '好友1' &#125;, &#123; _id: 2, name: '好友1' &#125;, &#123; _id: 3, name: '好友1' &#125;,];const groupMembers = [ &#123; _id: 1, name: '好友1' &#125;, &#123; _id: 2, name: '好友1' &#125;,] 现在一步一步来看数组的操作 一,两个数组里的每一项分别为元素时12345const arr1 = ['', '100', '120', '125', '125', '130', '130'];const arr2 = ['', '120', '125', '125', '130'];请问如何求得两个数组之差？使得新数组为 arr3 = ['100','130'] 方法一:思路:用for循环比较arr1和arr2的每一项,如果相等,就删除1234567891011121314151617const arr1 = ['', '120', '125', '125', '130', '130', '130', '130', '130'];const arr2 = ['', '120', '125', '130'];for (let i = arr1.length - 1; i &gt;= 0; i--) &#123; a = arr1[i]; for (let j = arr2.length - 1; j &gt;= 0; j--) &#123; b = arr2[j]; if (a == b) &#123; arr1.splice(i, 1); arr2.splice(j, 1); break; &#125; &#125;&#125;console.log(arr1); // ['125','130','130','130','130'] 方法二:思路:将第一个数组存入一个对象，这样就已经去重了；再把第二个数组中的元素当作key从对象中删除。1234const m = &#123;&#125;;arr1.forEach(function(al)&#123;m[al]=al;&#125;)arr2.forEach(function(bl)&#123;delete m[bl];&#125;)console.dir(Object.keys(m)) 方法三:思路:声明一个新的数组arr3,比较arr1和arr2,如果arr1中有和arr2不相等的就放入arr3中,用到了es6中关于数组的新方法findIndex(),稍后会详细的介绍;123456789const arr1 = ['', '100', '120', '125', '125', '130', '130'];const arr2 = ['', '120', '125', '125', '130'];const arr3 = [];arr1.forEach((a)=&gt;&#123; let c = arr2.findIndex(b =&gt;a === b); if (c &gt; -1) delete arr2[c]; else arr3.push(a);&#125;);console.log(arr3) //['100', '130'] 二, arr1中的每一项都是对象,arr2中的每一项都是元素12const a = [&#123; id: 15 &#125;, &#123; id: -1 &#125;, &#123; id: 0 &#125;, &#123; id: 3 &#125;, &#123; id: 12.2 &#125;];const b = [15, 3]; 方法一123a.filter(item =&gt; &#123; return !b.includes(item.id); &#125;);或a.filter(item =&gt; &#123; return b.indexOf(item.id) === -1; &#125;); 方法二:1a=a.filter((x)=&gt;b.every((y)=&gt;y!=x.id)) 方法三:1234567891011const a = [&#123; id: 15 &#125;, &#123; id: -1 &#125;, &#123; id: 0 &#125;, &#123; id: 3 &#125;, &#123; id: 12.2 &#125;];const b = [15, 3];for(index in a)&#123; if(b.indexOf(a[index]['id'])&gt;=0) a.splice(index,1);&#125;console.log(a);或const result = a.filter(function (item) &#123; return b.indexOf(item.id) &lt; 0; &#125;) 三,arr1中的每一项都是对象,arr2中的每一项也都是对象,现在回到主题123456789const a = [ &#123;_id: 1&#125;, &#123;_id: 2&#125;, &#123;_id: 3&#125;,];const b = [ &#123;_id: 2&#125;, &#123;_id: 4&#125;,] 解决方法一:1const c = a.filter(x =&gt; !b.find(y =&gt; y._id === x._id)); // [ &#123; _id: 1 &#125;, &#123; _id: 3&#125; ] 解决方法二:1const c = a.filter(x =&gt; b.every(y =&gt; y._id !== x._id)); 四,介绍一下上面用到的数组实例中的find(), findIndex(), includes()find()find()用于找出第一个符合条件的数组成员,它的参数是一个回调函数,所有的数组成员依次执行该回调函数,直到找到第一个返回值为true的成员,然后返回该成员,如果没有的话,返回undefined12[0, 4, -5, -10].find((n) =&gt; n &lt; 0);// -5 上面代码找出数组中第一个小于0的成员1234[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 find方法的回调函数可以接受三个参数,当前的值,当前的位置和原数组 findIndex()findIndex()方法的用法与find()方法类似,返回第一个符合条件的数组成员的位置,如果所有成员都不符合,则返回-1.1234[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 两个方法都可以发现NAN,弥补了数组的indexOf方法的不足12345[NaN].indexOf(NaN)// -1[NaN].findIndex(y =&gt; Object.is(NaN, y))// 0 indexOf方法无法识别数组的NaN成员,但是findIndex方法可以借助Object.is方法做到 includes()Array.prototype.includes方法返回一个布尔值,表达某个数组是否包含给定的值,与字符串的includes方法类似 123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 该方法的第二个参数表示搜索的起始位置,默认为0,如果第二个参数为负数,表示倒数的位置;如果这是它大于数组长度(比如第二个参数为-4.但是数组长度为3),则会重置为从0开始12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true 没有该方法之前,我们通常使用数组的indexOf方法,检查是否包含某个值123if (arr.indexOf(el) !== -1) &#123; // ...&#125; indexOf方法有两个缺点,一是不够语义化.它的含义是找到参数值的第一个出现位置.所以要去比较是否不等于-1,而是,它内部使用严格相等运算符(===)进行判断,这会导致对NaN的误判12[NaN].indexOf(NaN)// -1 includes使用的是不一样的判断算法，就没有这个问题。12[NaN].includes(NaN)// true 参考 数组减去另一个数组 js 根据一个数组元素，删除另一个数组中的对象 ECMAScript6入门之数组的拓展]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端路由history vs hash]]></title>
    <url>%2F2017%2F10%2F15%2F%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1history-vs-hash%2F</url>
    <content type="text"><![CDATA[history路由机制用户访问网页的历史记录通常会被保存在一个类似栈对象中,即history对象,点击返回就出栈,跳下一页就入栈.它提供了一些方法来操作页面的前进和后退: window.history.back()返回到上一个页面 window.history.forward()进入到下一个页面 window.history.go([delta])跳转到指定页面HTML5对history Api进行了增强,新增了两个Api和一个事件,分别为pushState,replaceState和onpopstatepushState是往history对象里添加一个新的历史记录,即压栈replaceState是替换history对象中的当前历史;这两个API相同之处都会操作浏览器的历史记录,而不会引起页面的刷新;不同之处在于,pushState会增加一条新的历史记录,而replaceState则会替换当前的历史记录当点击浏览器后退按钮或js调用history.back都会触发onpopstate事件,与其类似的还有一个事件:onhashchange hash路由机制我们经常在url中看到#,这个#有两个情况,一个是我们所谓的锚点,比如典型的回到顶部按钮原理,github上各个标题之间的跳转等,路由里的#不叫锚点,我们称之为hash,大型框架的路由系统大多都是哈希实现的onhashchange 事件在当前 URL 的锚部分(以 ‘#’ 号为开始) 发生改变时触发 hashhistory与browserhistory 使用 hashHistory，浏览器上看到的 url 会是这样的: /#/user/haishanh?_k=adseis 使用 browserHistory，浏览器上看到的 url 会是这样的：/user/haishanh 看起来当然browerHistory很好很理想,但browweHistory需要server端支持,而使用hashHistory的时候，因为 url 中 # 符号的存在，从 /#/ 到 /#/user/haishanh 浏览器并不会去发送一次 request，react-router 自己根据 url 去 render 相应的模块。 而使用 browserHistory 的时候，浏览器从 / 到 /user/haishanh 是会向 server 发送 request 的。所以 server 端是要做特殊配置的。比如用的 express 的话，你需要 handle 所有的路由 app.get(‘*’, (req, res) =&gt; { … })，使用了 nginx 的话，nginx也要做相应的配置。所以你的 App 是静态，没有服务端的话，只能用 hashHistory。]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoDB]]></title>
    <url>%2F2017%2F10%2F14%2FmongoDB%2F</url>
    <content type="text"><![CDATA[MongoDB是一个通用的非关系型数据库;把文档存在集合中;它们不需要相同的schema,每个文档都可以有不同的schemaMongoose是一个Node模块;Mongoose的基础知识如下: 打开或关闭MongoDB连接; 注册schema; 添加任务; 搜索文档 更新文档 删除文档首先可以用npm 命令安装Mongoose; 1npm install mongoose 1,连接的打开和关闭装好Mongoose,启动MongoDB服务器,用下面的代码建立到MongoDBd的连接,在下面的例子中是一个叫tasks的数据库12const mongoose = require(' mongoose');const db = mongoose.connect(' mongodb:// localhost/ tasks'); 如果要终止MongoDB创建的连接,1mongoose.disconnect(); 2,注册schema在用MongoDB管理数据时,需要注册schema123456const Schema = mongoose.Schema;const Tasks = new Schema(&#123; project: String, description: String &#125;);mongoose.model(' Task', Tasks); Mongoose的schema很强大.除了定义数据结构,还可以设定默认值,处理输入,以及加强校验 3,添加任务schema注册好后,你可以访问它,让Mongoose去工作,下面的代码用模型添加了一项任务12345678const Task = mongoose. model(' Task');const task = new Task();task.project = 'Bikeshed';task.description = 'Paint the bikeshed red.';task.save( function( err) &#123; if (err) throw err; console.log(' Task saved.');&#125;); 4,搜索文档Task模型的find方法可以用来查找所有文档,或者用一个JavaScript对象指明一个过滤标准来选择特定的文.下面这段代码搜索跟特定项目相关的任务,并输出每项任务的唯一ID和描述1234567const Task = mongoose.model(' Task');Task.find(&#123;' project': 'Bikeshed'&#125;, function( err, tasks) &#123; for (const i = 0; i &lt; tasks.length; i++) &#123; console.log(' ID:' + tasks[ i]._ id); console.log( tasks[ i]. description); &#125;&#125;); 5,更新文档尽管用模型的find方法可以定位一个文档,然后修改并保存它,但Mongoose还有一个update方法专门来做这个.下面的代码用Mongoose更新了一个新的文档 12345678910const Task = mongoose. model(' Task');Task.update( &#123;_id: '4e65b793d0cf5ca508000001'&#125;, // 用 内部 ID 更新 &#123;description: 'Paint the bikeshed green.'&#125;, &#123;multi: false&#125;, //只 更新 一个 文档 function( err, rows_ updated) &#123; if (err) throw err; console.log(' Updated.'); &#125;); 6,删除文档在Mongoose中,一旦你取到了文档,要删除它很容易.你可以用文档的内部ID(或其他任何条件,如果你用find代替finById的话)获取和删除文档,代码就像下面弄这样1234const Task = mongoose.model(' Task');Task.findById(' 4e65b3dce1592f7d08000001', function( err, task)&#123; task. remove();&#125;); 友情链接 robomongo下载]]></content>
      <categories>
        <category>mongoDB</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2017%2F10%2F12%2F2017-10-12-git%2F</url>
    <content type="text"><![CDATA[1,工作区,暂存区,本地仓库,远程仓库 2,git 添加远程仓库地址/拉项目/推项目1234567891011git remote add mayun https://git.oschina.net/fenmiaojinrong/fmjr.gitgit branch --set-upstream master mayun/mastergit pullgit add .git commit -m&quot;解决冲突&quot;git push 3,git -版本回退本地回退版本1git reset &lt;the-hash&gt; 远程回退版本12git push --force &lt;remote&gt; &lt;the-hash&gt;:&lt;the remote branch&gt; rebase1git rebase -i &lt;the-hash&gt; 清空本地改动1git clean -fd 取消应该被跟踪的改动12git rm --cached &lt;file&gt; 临时取消工作区指定文件改动123git update-index --assume-unchanged &lt;file&gt; git update-index --no-assume-unchanged &lt;file&gt; 4,在master上建了一个分支next,但是master上有改动,需要next主动去合并master分支1next merge master 5,git -远程仓库法人删除和重命名在新版 Git 中可以用 git remote rename 命令修改某个远程仓库在本地的简称，比如想把 pb 改成paul，可以这么运行：1234$ git remote rename pb paul$ git remoteoriginpaul 注意，对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master分支现在成了paul/master。 碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令123$ git remote rm paul$ git remoteorigin git -拉取远程分支1git checkout --track remotes/origin/react 6,友情链接 windows上Git下载 progit]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年国庆节-杭州&&上海]]></title>
    <url>%2F2017%2F10%2F09%2F2017-10-09-%E5%9B%BD%E5%BA%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[10.01~10.02 coding at home今年的国庆节和中秋节一共八天假,期待了很久的假期;前两天自己在家写了两天代码,研究了一下项目用meteor和react结合做全栈; 10.03 浙大 + 将军山 5点起床,打车去首都机场,前往杭州,打印登机牌,办理行李托运,最后安检的时候被扣下了一瓶海飞丝,(规定是不允许带超过100ml的液体,哎,也是第一次做飞机,平常去的地方都特别近),大概在天上飞了两个半小时,飞机上的风景很美很美,看到了蓝天白云,上午10点左右,到达杭州,跟在天上看到的完全是两个样子,没有蓝天白云. 查找路线,坐公交去定好的酒店,杭州的公交支持支付宝直接付款,这个真的很方便,不用直接去换零钱; 在酒店里休息了一下就开始规划这几天在杭州的路线,浙大就在酒店的附近,就骑着车子去了,杭州的路比北京的要宽很多,路两边的树很多,而且树长的都很大; 浙大玉泉校区 将军山 10.04 西湖 + 杭州海底世界 + 京杭运河来杭州当然一定要去看一下西湖,于是就骑着车子去西湖了,人特别的多, 晚上,游京杭运河,夜景真的很美很美,杭州真的很会使用灯光搭配;武林门码头坐游船,差不多一百元一位,白天有水上的公交,才三元,所以你可以晚上早点去,然后做最后一班公交,这样即会节省一部分开支,又可以看到晚上的夜景 10.05 西溪 + 断桥 大概断桥就是被人压断的吧,O(∩_∩)O哈哈~ 10.06 东方明珠 + 上海世贸大厦最高观光厅 10.07 上海迪士尼迪士尼人真的太多了,基本玩一个项目都得等一个多小时,所以去玩的时候一定要提前做好攻略;(看过欢乐颂2的大概都知道,里面有一个特别浪漫的情节就是在迪士尼拍的,但是电视剧毕竟是电视,看看就好,✧(≖ ◡ ≖✿)嘿嘿,真实的情况你懂得) 10.08 回北京]]></content>
      <categories>
        <category>life</category>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现toolTip]]></title>
    <url>%2F2017%2F09%2F27%2F2017-09-27-css%E5%AE%9E%E7%8E%B0toolTip%2F</url>
    <content type="text"><![CDATA[1,常用border来实现三角形 原理: 宽高都不设置(即为0),只设置边框,如果4个边框都设置宽度(border-width),样式(border-style)和颜色(border-color)12345678.test &#123; width:0; height: 0; border-top: 100px solid red ; border-bottom: 100px solid blue; border-left: 100px solid green; border-right: 100px solid yellow;&#125; 效果如图 上面看到的都是三角形,其实想实现单个三角形只需把其他三个三角形的border-color设置为透明色就可以了这样就实现了三角形123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;各种三角形&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; margin-top: 50px; &#125; .triangle-up &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid red; &#125; .triangle-down &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid red; &#125; .triangle-left &#123; width: 0; height: 0; border-top: 50px solid transparent; border-right: 100px solid red; border-bottom: 50px solid transparent; &#125; .triangle-right &#123; width: 0; height: 0; border-top: 50px solid transparent; border-left: 100px solid red; border-bottom: 50px solid transparent; &#125; .triangle-topleft &#123; width: 0; height: 0; border-top: 100px solid red; border-right: 100px solid transparent; &#125; .triangle-topright &#123; width: 0; height: 0; border-top: 100px solid red; border-left: 100px solid transparent; &#125; .triangle-bottomleft &#123; width: 0; height: 0; border-bottom: 100px solid red; border-right: 100px solid transparent; &#125; .triangle-bottomright &#123; width: 0; height: 0; border-bottom: 100px solid red; border-left: 100px solid transparent; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li class="triangle-up"&gt;&lt;/li&gt; &lt;li class="triangle-down"&gt;&lt;/li&gt; &lt;li class="triangle-left"&gt;&lt;/li&gt; &lt;li class="triangle-right"&gt;&lt;/li&gt; &lt;li class="triangle-topleft"&gt;&lt;/li&gt; &lt;li class="triangle-topright"&gt;&lt;/li&gt; &lt;li class="triangle-bottomleft"&gt;&lt;/li&gt; &lt;li class="triangle-bottomright"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 2,css实现toolTip(实心三角箭头)原理: 一个三角形绝对定位到主体元素边界处并连接起来 把三角形的颜色换成和主体元素一致的背景色就可以123456789101112131415161718.test &#123; position: relative; width: 300px; height: 100px; border-radius: 20px; margin: 100px auto; background-color: #A5C4EC;&#125;.test:before&#123; content: ''; display: block; position: absolute; bottom: -20px; left: 80px; border-left: 20px solid transparent ; border-right: 20px solid transparent; border-top: 20px solid #A5C4EC;&#125; 3,css实现toolTip(空心三角箭头)源码如下原理: 一个边框颜色的三角形绝对定位到主体元素边界处并连接起来 另一个主体元素背景色的三角形绝对定位并覆盖到第一个三角形上面 第二个三角形相较于第一个三角形定位上偏移距离应等于边框厚度1234567891011121314151617181920212223242526272829.test &#123; position: relative; width: 300px; height: 100px; border-radius: 20px; margin: 100px auto; border: 6px solid blue; background-color: #A5C4EC;&#125;.test:before&#123; content: ''; display: block; position: absolute; bottom: -20px; left: 80px; border-left: 20px solid transparent ; border-right: 20px solid transparent; border-top: 20px solid blue;&#125;.test:after&#123; content: ''; display: block; position: absolute; bottom: -14px; left: 80px; border-left: 20px solid transparent; border-right: 20px solid transparent; border-top: 20px solid #fff;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .wrap &#123; width: 1000px; margin: 0 auto; &#125; /* 向下 */ .toolTip-bottom &#123; position: relative; width: 300px; height: 100px; border: 1px solid #A5C4EC; border-radius: 20px; margin: 100px auto; background-color: #fff; &#125; .toolTip-bottom:before&#123; content: ''; display: block; position: absolute; bottom: -20px; left: 80px; border-left: 20px solid transparent ; border-right: 20px solid transparent; border-top: 20px solid #A5C4EC; &#125; .toolTip-bottom:after&#123; content: ''; display: block; position: absolute; bottom: -17.6px; left: 80px; border-left: 20px solid transparent; border-right: 20px solid transparent; border-top: 20px solid #fff; &#125; /* 向上 */ .toolTip-top &#123; position: relative; width: 300px; height: 100px; border: 1px solid #A5C4EC; border-radius: 20px; margin: 100px auto; background-color: #fff; &#125; .toolTip-top:before&#123; content: ''; display: block; position: absolute; top: -20px; left: 80px; border-left: 20px solid transparent ; border-right: 20px solid transparent; border-bottom: 20px solid #A5C4EC; &#125; .toolTip-top:after&#123; content: ''; display: block; position: absolute; top: -17.6px; left: 80px; border-left: 20px solid transparent; border-right: 20px solid transparent; border-bottom: 20px solid #fff; &#125; /* 向左 */ .toolTip-left &#123; position: relative; width: 300px; height: 100px; border: 1px solid #A5C4EC; border-radius: 20px; margin: 100px auto; background-color: #fff; &#125; .toolTip-left:before &#123; content: ''; display: block; position: absolute; left: -20px; top: 30px; border-top: 20px solid transparent ; border-bottom: 20px solid transparent; border-right: 20px solid #A5C4EC; &#125; .toolTip-left:after &#123; content: ''; display: block; position: absolute; left: -18px; top: 30px; border-top: 20px solid transparent ; border-bottom: 20px solid transparent; border-right: 20px solid #fff; &#125; /* 向右 */ .toolTip-right &#123; position: relative; width: 300px; height: 100px; border: 1px solid #A5C4EC; border-radius: 20px; margin: 100px auto; background-color: #fff; &#125; .toolTip-right:before &#123; content: ''; display: block; position: absolute; right: -20px; top: 40px; border-top: 20px solid transparent ; border-bottom: 20px solid transparent; border-left: 20px solid #A5C4EC; &#125; .toolTip-right:after &#123; content: ''; display: block; position: absolute; right: -18px; top: 40px; border-top: 20px solid transparent ; border-bottom: 20px solid transparent; border-left: 20px solid #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;div class="toolTip-bottom"&gt;&lt;/div&gt; &lt;div class="toolTip-top"&gt;&lt;/div&gt; &lt;div class="toolTip-left"&gt;&lt;/div&gt; &lt;div class="toolTip-right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图如下 参考 aboutmegithubblog]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下运行Rocket.chat]]></title>
    <url>%2F2017%2F09%2F17%2FMac%E4%B8%8B%E8%BF%90%E8%A1%8CRocket-chat%2F</url>
    <content type="text"><![CDATA[1,简介 github Rocket.chat是特性最丰富的Slack开源替代品之一 主要功能：群组聊天，直接通信，私聊群，桌面通知，媒体嵌入，文件上传，语音/视频聊天，截图等等 Rocket.chat原生支持windows,Mac OSX, Linux, ios和Android平台 2，准备工作由于Rocket.chat使用的是Meteor框架，而Meteor框架是对Node.js的封装，源码中又使用到了CoffeeScript.js,使用数据库是MongDB，所以在Rocker.chat上做二次开发，需要学习的技术有Meteor, Node.js, CoffeeScript.js,MongDB； 其他资料 CoffeeScipt中文网 Meteor中文网 Rocket.chat要运行，必须安装Node.js,NPM,Meteor(包含了Mongdb)node和npm的安装大家肯定特别熟悉，下面说一下meteor的安装过程 3,安装meteor1curl https://install.meteor.com/ | sh 创建一个小工程的指令，123meteor create meteorAppcd meteorAppmeteor 在浏览器中输入：http://localhost:3000/ 4,下载和运行Rocket.chat下载Rocet.chat最好使用git 的命令1git clone git clone https://github.com/RocketChat/Rocket.Chat.git 等工程源码下载完毕后，进入对应的文件夹，然后运行12cd Rocket.Chatnpm start 在执行npm start的过程中，需要注意一下问题，否则可能会启动不了 1,运行会特别慢,建议加上修改源为淘宝源，具体方法如下参考： 1npm config set registry https://registry.npm.taobao.org 2,运行过程需要翻墙，因为国外的npm包在国内下载可能就被墙了 我在安装的过程中出现报错： 找了phantomjs镜像单独安装了一下速度很快，就成功了,😊,然后把phantomjs添加到环境变量(方法如下)12345671,cd phantomjs2,cd bin3,pwd //注: 需要输出的复制地址4,cd ~ // 回到根目录5,vim .zshrc6,添加到path7,source .zshrc // 保存修改 运行成功命令行如下 运行成功浏览器中如下 参考 如果运行中出现其他的问题欢迎与我交流aboutmegithubblog]]></content>
      <categories>
        <category>meteor</category>
        <category>Rocket.chat</category>
      </categories>
      <tags>
        <tag>meteor</tag>
        <tag>Rocket.chat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心塞！又一次被自己蠢哭]]></title>
    <url>%2F2017%2F09%2F08%2F%E8%A2%AB%E9%AA%97%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[很晚了，但是今天就是睡不着，想把今天发生在我身上的事情总结一下，看完之后肯定会觉得我很傻很笨，这一次我将不会再为自己辩解；承认自己被骗是一个很痛苦的事情，不知道谁能体会到； 我发现我真的好笨，这次被骗很难过，并不仅仅是骗了200块钱，而是她还欺骗了我的感情，我那么相信她，跟她聊了好多实话，很多人跟我说过不要太容易去相信别人，我爸妈，还有很多朋友都这么跟我说，我很不愿意接受现实生活中哪有那么多坏人，每次都会反驳一句：你们不要老把别人想得那么坏。。。所以就有了之后的一次又一次被骗，之前碰到乞丐都会给一些钱，还有路边说钱包被偷的没钱吃饭的，借钱回家的，还有1700多买了个酷派合约机，一个月话费120(当时都没工作，那来那么多钱交话费)甚至还有骗你拿自己身份证办银行卡的，很多很多，经历了那么多被骗，以为自己现在成熟很多了， 这次美容院被骗事件，我真的是不知道怎么办，只是问个路，然后那个人就拐着你的胳膊就说我领你去，当时还特庆幸自己遇到一个特别好的人，结果就把我领到店里了，我真的很生气，当时准备扭头就走，可是接下来发生的事就像下面百度到的这些美容院骗术发生的一模一样； http://jingyan.baidu.com/article/a17d52855420a78098c8f2f9.html 让脸上抹了一些膏状液体，拿着电疗忆，过一会就变成了黑色(（PS 涂的东西是一种重金属测试膏，百度“美容院用重金属测试膏欺诈顾客”，可以看到相关新闻报道，据说这是十年前就有的骗局。。）)，说是原价700多的现在因为4周年店庆，300多，最后一天，我坚持不做，想走，她死活不让我走，说现在不能走，出去就会感染，过敏，皮囊炎，毁容。。。。(正常人听到这些多少都会还害怕吧，不过现在想想她说怎样就会怎么样么，20多年了，皮肤就这样，很多人一辈子没去去过美容院，也没见自己长着长着毁容的)说你现在不能走，她要对你负责，怎么办，她又说这样吧，给你个学生特惠的190，然后你下次来体验一把全脸的，我意识到这是不掏钱不让走的节奏啊，而且他们人多，我自己，又不敢怎么，但是又不愿相信自己被骗了，还是愿意相信那个人所说的，还傻乎乎的打算有空来体验一把（被自己蠢哭）。 百度完之后，终于意识到自己真的是被骗了，看着百度搜索出来的美容院骗局，解析街边美容院骗局；很多评论都是2017年的。老掉牙的骗局，现在我还被骗，哎，不过看到他们比我骗得钱多，而且很多人都被骗过，心里平衡了很多（明明知道这是一种很不好的心里活动，就当是安慰自己吧） 真的很希望骗子你们不要再找我了，骗我就是一骗一个准，突然想到，自己能安全活这么大还是很不容易的，所以身边的你们要好好珍惜 很渴望骗子能少一些，人与人之前多一点真诚。这样当真正有需要帮助的人需要帮助的时候，大家才不会那么冷漠。希望那些骗子们不要再玩心理战了，这样真的很可恶，不仅骗钱，还骗感情。]]></content>
      <categories>
        <category>life</category>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用vue,你知道 keep-alive 么]]></title>
    <url>%2F2017%2F09%2F06%2Fvue%E7%BB%84%E4%BB%B6%E4%B9%8Bkeep-alive%2F</url>
    <content type="text"><![CDATA[项目中写vue也没注意到&lt;keep-alive&gt;&lt;/keep-alive&gt;这个组件,最近在深入的研究vue组件的生命周期函数,每一个函数都是干嘛的,然后其中有activated和deactivated这两个函数与&lt;keep-alive&gt;&lt;/keep-alive&gt;这个组件有关 activated: keep-alive组件激活时调用 deactivated: keep-alive组件停用时调用keep-alive用法 &lt;keep-alive&gt;包裹动态组件时,会缓存不活动的组件实例,而不是销毁它们 &lt;keep-alive&gt;是一个抽象组件:它自身不会渲染一个DOM元素,也不会出现在父组件链中 当组件在&lt;keep-alive&gt;内被切换,它的activated和deactivated这两个生命周期钩子函数将会被对应执行具体的实例如下 是一个简单的tab切换,可以尝试把&lt;keep-alive&gt;去掉之后,对比一下,然后就会发现它的好处 test.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;div class="test"&gt; &lt;div class="testNav"&gt; &lt;div :class="&#123;'selected':tab === 1,'testTitle':true&#125;" @click="toTab(1)"&gt;标题一&lt;/div&gt; &lt;div :class="&#123;'selected':tab === 2,'testTitle':true&#125;" @click="toTab(2)"&gt;标题二&lt;/div&gt; &lt;/div&gt; &lt;div class="container"&gt; &lt;keep-alive&gt; &lt;Test1 v-if="tab === 1"&gt; &lt;/Test1&gt; &lt;Test2 v-else&gt; &lt;/Test2&gt; &lt;/keep-alive&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Test1 from './test1.vue'; import Test2 from './test2.vue'; export default &#123; data() &#123; return &#123; tab: 1, &#125;; &#125;, components: &#123; Test1, Test2, &#125;, methods: &#123; toTab(index) &#123; this.tab = index; &#125;, &#125;, &#125;&lt;/script&gt;&lt;style lang="less"&gt;.test &#123; width: 100%; .testNav &#123; height: 60px; line-height: 60px; display: flex; border-bottom: 1px solid #e5e5e5; .testTitle &#123; flex: 1; text-align: center; &#125; .selected &#123; color: red; &#125; &#125;&#125;&lt;/style&gt; 测试结果如下:注意看一下页面和控制台输出的信息,可以更加直观的注意到&lt;keep-alive&gt;的作用及activated和deactivated这两个函数什么时候会被触发 打开页面,会出现下面这样 用setTimeout模拟请求后端接口的场景 点击title2,出现下面的情况 再次点击title1,出现下面的情况,你会发现从后端请求的数据会快速显示出来,但是如果你此时不用 test1.vue和test2.vue的相关代码如下: test1.vue123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class="test1"&gt; test1 &#123;&#123;testInfo1&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; testInfo1: '', &#125;; &#125;, activated() &#123; console.log('测试1被激活'); &#125;, deactivated() &#123; console.log('测试1被缓存'); &#125;, created() &#123; setTimeout(() =&gt; &#123; this.testInfo1 = '这是测试一的数据'; &#125;, 2000); &#125;, &#125;&lt;/script&gt; test2.vue123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; test2 &#123;&#123;testInfo2&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; testInfo2: '', &#125; &#125;, activated() &#123; console.log('测试2被激活'); &#125;, deactivated() &#123; console.log('测试2被缓存'); &#125;, created() &#123; setTimeout(() =&gt; &#123; this.testInfo2 = '这是测试二的数据'; &#125;, 2000); &#125;, &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2F2017%2F09%2F06%2Fflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[使用flex布局flex使用方法很简单,只需要将其display属性设置为flex即可,也可以设置行内的flex,记得webkit内核的浏览器,必须加上-webkit, 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。123456.ele &#123; display: -webkit-flex; diaplay: flex; display: inline-flex; display: -webkit-inline-flex;&#125; 在flex中,最核心的概念就是容器和轴,其中容器分为父容器和子容器,轴分为主轴和交叉轴(主轴默认为水平方向,方向向右,交叉轴为主轴顺时针旋转90度) 父容器属性父容器有六个属性 1,flex-direction: 主轴方向. 2,flex-wrap: 超出父容器子容器的排列方式 3,flex-flow: flex-direction属性和flex-wrap属性的简写方式 4,justify-content: 子容器在主轴的排列方向 5,align-items: 子容器的交叉轴上的排列方式 6,align-content: 多根轴线的对齐方式 flex-direciton属性flex-direction属性决定主轴的方向(主轴的方向不一定是水平的,这个属性就是设置主轴的方向,主轴默认是水平方向,从左至右)123456.box &#123; flex-direction: row; // 默认值,主轴为水平方向,起点在左端,从左到右 flex-direction: row-reverse; // 主轴为水平方向,起点在右端,从右到左 flex-direction: column; // 主轴为垂直方向,起点在上端,从上到下 flex-direction: column; // 主轴为垂直方向,起点在下端,从下到上&#125; flex-wrap属性flex-wrap属性决定自容器如果在一条轴线排不下时,如何换行12345.box &#123; flex-wrap: nowrap; // 默认,不换行 flex-wrap: wrap; // 换行,第一行在下面 flex-wrap: column; // 换行,第一行在=上面&#125; 子容器也有6个属性 1,order: 子容器的排列顺序 2,flex-grow: 子容器剩余空间的拉伸比例 3,flex-shrink: 子容器超出空间的压缩比例 4,flex-basis: 子容器不伸缩情况下的原始尺寸 5,flex: 子元素的flex属性是flex-grow, flex-shrink, flex-basis的简写 6,align-self: 允许单个子容器与其他字容器不一样的对齐方式,可覆盖父元素aligns-items属性(交叉轴),默认是auto,表示继承父元素的align-items属性,如果没有付元素,则等同于strech order属性order属性定义子容器的排列顺序,数值越小,排列越靠前123item &#123; order: &lt;interger&gt;&#125; flex-grow属性flex-grow属性定义子容器的放大比例,默认为0123item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果子容器的flex-grow属性都为1,则他们将等分剩余空间(如果有的话).如果一个项目的flex-grow属性为2,其他项目都为1,则前者占据的剩余空间将比其他项多一倍; flex-shrink属性flex-shrink定义了子容器的缩小比例,默认为1,如果空间不足,该项目将缩小123item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有子容器的flex-shrink属性都为1,当空间不足时,都将等比例缩小.如果一个项目的flex-shrink的属性为0,其他项目都为1,则空间不足时,前者不缩小;负值对该属性无效 flex-basis属性flex-basis属性定义了在分配多余空间之前,项目占据了主轴空间,浏览器根据这个属性,计算主轴是否有多余空间.它的默认值为auto,即项目的本来大小;123item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设置跟width和height属性一样的值(比如350px),则项目将占据固定空间 flex属性flex是flex-grow,flex-shrink,flex-basis的缩写,默认值为0 1 auto。后两个属性可选123.item &#123; flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]&#125; align-self属性align-self属性允许单个子容器有与其他子容器不一样的对齐方式，可覆盖align-items属性，默认为auto,表示继承父元素align-items属性，如果没有父元素，则等同于stretch123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto,其他都与align-items属性完全一致。 参考]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除css默认样式的总结]]></title>
    <url>%2F2017%2F09%2F06%2Fcss%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F%E7%9A%84%E6%B8%85%E9%99%A4%2F</url>
    <content type="text"><![CDATA[我们写css的时候经常会遇到要清楚一些默认的样式,其实每次做项目中需要清除的样式就经常是那么几个,最常见的比如 清除表单元素input,select,`textarea的默认样式, CSS3中隐藏滚动条但仍能继续滚动, 多行文本溢出省略号显示等等, 所以就总结了一下,持续更新中…,也请大家多多贡献更多的常见的需要清除默认样式的方法😊 1,多行文本溢出省略号显示 让文本只显示一行，然后溢出省略号显示 123overflow: hidden;text-overflow: ellipsis;white-space: nowrap; 让文本显示两行，然后溢出部分省略号显示12345line-height: 1.3rem;max-height: 2.6rem;display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2; 2，CSS3中隐藏滚动条但仍能继续滚动1234::-webkit-scrollbar &#123; width: 0px; height: 0px;&#125; 3, 解决iPhone中overflow:scroll;滑动速度慢或者卡的问题1-webkit-overflow-scrolling : touch; 4,消除input,textarea等的默认样式123456789input, button, select, textarea &#123; outline: none; -webkit-appearance: none; border-radius: 0; border:0;&#125;textarea&#123; resize:none;&#125; outline: none;去掉chrome浏览器自带的点击input框出现边框情况 -webkit-appearance: button;使元素标签看起来像个按钮样式,意思定义了按钮样式-webkit-appearance: none;去掉按钮样式 border-radius: 0; 去掉圆角border:0; 去掉border textarea{resize:none}取消chrome下textarea可拖动放大：Aboutaboutmegithubblog]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结微信小程序开发中遇到的坑]]></title>
    <url>%2F2017%2F09%2F01%2Fwxapp%2F</url>
    <content type="text"><![CDATA[总结微信小程序开发中遇到的坑,一些坑你得一个一个的跳啊,/(ㄒoㄒ)/~~ 1,页面跳转和参数传递实例 首先说一下我遇到的需求有一个我的消息页面,里面的数据都是后端返回的,返回的数据大致如下,有一个是数据url是要控制跳转到哪个页面,可能是tab页面也可能是非tab页面,但是微信小程序中跳转到tab和非tab页面用的api不是同一个,但是在页面中渲染肯定是要用到循环的,难道要再多个参数来判断是跳转到tab页面还是非tab页面? 1234567891011121314151617[ &#123; "id": 2121, "title": "test", "body": "test", "url": "url", "pic": "pic", "created_at": "2017-07-01 12:34:56" &#125;, &#123; "id": 2122, "title": "test", "body": "test", "url": "url", "pic": "pic", "created_at": "2017-07-01 12:34:56" &#125;,] 后一般的小程序中我用的框架是wepy,底部的tab组件就是我自己写的,没有用到小程序自己提供的那一个,因为我们还要实现一个需求,有消息时,底部tab会出现小红点,还有以下弹窗要把底部tab覆盖掉,这些需求如果用小程序提供的那一个tab组件的话根本实现不了;而且不用wepy框架的话,自己做一个tab实现的过程很恶心,小程序虽然实现了组件化,但是它实现的组件化bong不想vue和react那样实现的是真正的组件化,你需要哪个组件就直接import进来,小程序的组件化实现可查看官方文档,js,css和html都是要分别引入的 自己实现的tab页面整体是一个非tab页面,所有整个小程序中就不存在绝对的tab页面,所以用navigator这个组件,想要跳转到tab页面可以通过在url上拼接参数 123456&lt;view class="mesList" wx:for="&#123;&#123;unReadList&#125;&#125;" wx:key="unique"&gt; &lt;navigator url="/pages/index?tab=0" hover-class="none" &gt; &lt;text&gt;&#123;&#123;item.body&#125;&#125;&lt;/text&gt; &lt;view class="messageTime"&gt;&#123;&#123;item.created_at&#125;&#125;&lt;/view&gt; &lt;/navigator&gt;&lt;/view&gt; 然后再index页面的onload中判断显示哪个tab123456onLoad(options) &#123; if (options &amp;&amp; options.tab) &#123; this.tab = parseInt(options.tab); this.$apply(); &#125;&#125; 2,微信小程序授权处理 微信小程序提示授权弹窗,如果用户第一次点击拒绝之后,一段时间将不会再次弹出来,然后用户又不知道什么原因用不了小程序,这是个很糟糕的用户体验,我们应该优雅的处理这种情况 采用的解决方法参考 3, 登录问题的处理 两个登录接口,一个get,判断是否已经还需要登录,如果返回true,则需要登录,如果返回false,则不需要登录 如果返回true,则需要去请求更一个post的登录接口,这时,你需要获取第一个get请求的返回信息中的session,之后每次请求求都需要带上他 在返回true的时候还需要做一件事儿,就是把返回信息中的session存储到storage,即调用setStorage,然后在之后每次请求数据的时候在headers里加上这个字段1234567891011121314151617181920212223242526272829function getStorage(key) &#123; return new Promise(function (resolve, reject) &#123; // 先判断本地数据存储有没有cookie wx.getStorage(&#123; key: key, success: function (res) &#123; resolve(res.data); &#125;, fail: function (res) &#123; resolve(null); &#125;, &#125;); &#125;);&#125;function setStorage(key, value) &#123; return new Promise(function (resolve, reject) &#123; wx.setStorage(&#123; key: key, data: value, success: function (res) &#123; // TODO: 不知道返回什么 resolve(res.data); &#125;, fail: function (res) &#123; reject(res.errMsg); &#125;, &#125;); &#125;);&#125; 4,wx.getStorage安卓手机上返回的错误信息是getStorage:fail,ios,getStorage:fail data not found 在判断一些api返回的错误信息时,最好不要通过判断具体的错误信息来处理错误12345678910111213141516171819202122function getStorage(key) &#123; return new Promise(function (resolve, reject) &#123; // 先判断本地数据存储有没有cookie wx.getStorage(&#123; key: key, success: function (res) &#123; resolve(res.data); &#125;, fail: function (res) &#123; resolve(null); // 下面注释的部分即为刚开始犯的错误,导致有可能ios或安卓或部分机型显示不出数据 // if (res.errMsg == 'getStorage:fail' || res.errMsg == 'getStorage:fail data not found') &#123; // console.log('没有cookie'); // resolve(null); // &#125; else &#123; // console.log('这是一个问题'); // reject(res.errMsg); // &#125; &#125;, &#125;); &#125;);&#125; 5,小程序解决异步 如果项目中没有用到babal,小程序本身的支持只支持到es6的语法,所以解决异步的问题就不能使用es7的async和await,只能使用promise来解决异步,但是每个api上都进行一次封装(如下),这种做法太恶心了 123456789101112function login() &#123; return new Promise(function (resolve, reject) &#123; wx.login(&#123; success: function (res) &#123; resolve(res); &#125;, fail: function (res) &#123; reject(res.errMsg); &#125;, &#125;); &#125;);&#125; 基于微信的API的prototype上进行了promise的封装 123456789101112131415function promiseify(func) &#123; return (args = &#123;&#125;) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; func.call(wx, Object.assign(args, &#123; success: resolve, fail: reject, &#125;)); &#125;) &#125;&#125;for (const key in wx) &#123; if (Object.prototype.hasOwnProperty.call(wx, key) &amp;&amp; typeof wx[key] === 'function') &#123; wx[`_$&#123;key&#125;`] = promiseify(wx[key]); &#125;&#125; 6,怎么保证在调用其他接口之前已经调用过登录的接口了 我采用执行队列的方式来解决,问题可以简化为有两个按钮,点击第一个按钮输出这是第几次输出d1,但是必须在点击完d2之后,isPrint变为true时,才允许输出,在isPrint为false的时候点击d1,需要把要输出的内容暂时存储起来,等isPrint变为true时,暂存起来的输出现在才可以输出出来12345678910111213141516171819202122232425262728293031323334// html &lt;div class="first"&gt;按钮一&lt;/div&gt; &lt;div class="second"&gt;按钮二&lt;/div&gt;// js const d1 = document.querySelector('.first'); const d2 = document.querySelector('.second'); let count = 0; // 用来记录第几次输出 let isPrint = false; // 是否允许输出 let arr = []; // 声明一个数组,用来存储 function clickCount() &#123; count++; console.log('这是第' + count + '次输出d1'); &#125; d1.onclick = function () &#123; console.log(isPrint); console.log(arr); if (isPrint) &#123; if (arr.length === 0) &#123; clickCount(); &#125; else &#123; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; arr[i](); &#125; &#125; &#125; else &#123; arr.push(clickCount); console.log('不允许输出'); &#125; &#125;; d2.onclick = function () &#123; isPrint = true; console.log(isPrint); &#125; 6,小程序问题 不支持跳转外部链接 text可以解析/n, 目前不支持识别图中二维码， 背景图片不能用本地图片， wx.navigateTo需要跳转的应用内非 tabBar 的页面的路径 wx.switchTab跳转到tabBar页面， wx.showToast(),icon只支持success和loading,但是支持image,且image优先级高于icon tabBar页面A navigatorTo 到页面B，然后B switchTab 到A，这里A会执行onShow()；但是我再从A跳到B再switchTab回来，A就不会再执行onShow()了， 7,总结 有时候在开发者工具上测试时是没有问题的,但是真机测试却有问题,所有开发过程中一定要在多个不同型号的手机上测试;很多时候IOS和安卓api返回的信息不同 在手机上打开调试的时候是好的,但是关闭调试后就会出现各种bug,遇到这种情况一定要一步步的去排查原因 8,后采用wepy重构小程序遇到的一些坑wepy文档1，Q: 怎么在page组件和component组件中回去到getApp(),就是app里面定义的函数,通过this.$parent只能拿到数据，拿不到方法?A:可以在this.$parent的_proto上拿到方法,即this.$parent.onLogin2, Q:怎么实现按需加载A:在compoent组件中自定义生命周期函数,并手动触发]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue生命周期详解]]></title>
    <url>%2F2017%2F08%2F29%2Fvue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[vue声明周期,在每个声明周期中都干了些什么? 1, vue的生命周期 beforeCreate: 组件实例刚刚被创建,组件属性计算之前,如data属性 created: 组件实例创建完成,属性已绑定,但是DOM还未完成,$el属性还不存在 beforeMount:模板编译/挂载之前 mounted: 模板编译/挂载之后 beforeUpdate: 组件更新之前 updated: 组件更新之后 activated: for keep-alive,组件被激活时调用 deactivated: for keep-alive,组件被移除时调用 beforeDestroy: 组件销毁前被调用 destoryed: 组件销毁后调用 ps:下面代码可以直接复制出去执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;script type="text/javascript" src="https://cdn.jsdelivr.net/vue/2.1.3/vue.js"&gt;&lt;/script&gt;&lt;body&gt; &lt;div id="app"&gt;&#123;&#123;a&#125;&#125;&lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; a: 'vuejs', &#125;, beforeCreate: function() &#123; console.log('创建前'); console.log(this.a); console.log(this.$el); &#125;, created: function() &#123; console.log('创建之后'); console.log(this.a); console.log(this.$el); &#125;, beforeMount: function() &#123; console.log('mount之前'); console.log(this.a); console.log(this.$el); &#125;, mounted: function() &#123; console.log('mount之后'); console.log(this.a); console.log(this.$el); &#125;, beforeUpdate: function() &#123; console.log('更新之前'); console.log(this.a); console.log(this.$el); &#125;, updated: function() &#123; console.log('更新完成'); console.log(this.a); console.log(this.$el); &#125;, beforeDestroy: function() &#123; console.log('组件销毁之前'); console.log(this.a); console.log(this.$el); &#125;, destroyed: function() &#123; console.log('组件销毁之后'); console.log(this.a); console.log(this.$el); &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; beforeCreated: el和data并未初始化created: 完成data数据的初始化,el没有beforeMount: 完成了el和data初始化mounted: 完成挂载 1打开命令行在命令行中输入vm.a = &apos;change&apos;;查看效果 activated和deactivated这两个生命周期函数涉及到&lt;keep-alive&gt;这个组件,所以想了解这个生命周期函数的可以看一下我的另一篇文章]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件通信]]></title>
    <url>%2F2017%2F08%2F29%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[组件通信是很重要的一部分,父组件怎么传数据给子组件,子组件怎么传递数据给父组件? 1,父组件给子组件传递数据 vue中使用props向子组件传递数据1): 子组件在props中创建一个属性,用于接收父组件传过来的值2): 父组件中注册子组件3): 在子组件标签中添加子组件props中创建的属性4): 把需要传给子组件的值赋给该属性 2,子组件向父组件传递数据子组件主要通过事件传递数据给父组件1), 子组件中需要以某种方式,例如点击事件的方法来触发一个自定义事件2),将需要传的值作为$emit的第二个参数,该值将作为实参数传给相应自定义事件的方法3),在父组件中注册子组件并在子组件标签上绑定自定义事件的监听 3,子组件向子组件传递数据vue找那个没有直接子组件对子组件传参的方法,建议将需要传递数据的在组件,都合并为一个组件,如果一定需要子组件对子组件传参,可以先传到父组件,再传到子组件,为了方便开发,vue推出了一个状态管理工具vuex,可以啃方便的实现组件之间的参数传递 具体的实例代码如下:可以自行参考相关代码在编辑器中尝试 父组件向子组件传递数据 123456789101112131415161718192021222324252627282930313233// 父组件向子组件传递数据&lt;!--msg 是在data中(父组件)定义的变量如果需要从父组件中获取logo的值,就需要使用props['msg'], 如30行在props中添加了元素以后,就不需要在data中(子组件)中再添加变量了--&gt;&lt;template&gt; &lt;div&gt; &lt;child @transferuser="getUser" :msg="msg"&gt;&lt;/child&gt; &lt;p&gt;用户名为:&#123;&#123;user&#125;&#125;(我是子组件传递给父组件的数据)&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import child from './child.vue'; export default &#123; components: &#123; child, &#125;, data() &#123; return &#123; user: '', msg: '我是父组件传给子组件的信息', &#125;; &#125;, methods: &#123; getUser(msg) &#123; this.user = msg; console.log(msg); &#125;, &#125;, &#125;;&lt;/script&gt; 子组件向父组件传递数据 12345678910111213141516171819202122232425262728293031323334// 子组件向父组件传递数据&lt;!--1.@ : 是 v-on的简写2.子组件主要通过事件传递数据给父组件3.当input的值发生变化时,将username传递给parent.vue,首先声明了一个setUser,用change事件来调用setUser4.在setUser中,使用了$emit来遍历transferUser事件,并返回this.username,其中transferuser是一个自定义事件,功能类似一个中转,this.username通过这个事件传递给父组件--&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;span&gt;用户名&lt;/span&gt; &lt;input v-model="username" @change='setUser'&gt;向父组件传值&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; username: '测试', &#125;; &#125;, props: &#123; msg: &#123; type: String, &#125;, &#125;, methods: &#123; setUser() &#123; this.$emit('transferuser', this.username); &#125;, &#125;, &#125;;&lt;/script&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的函数节流]]></title>
    <url>%2F2017%2F08%2F27%2Fjs%E7%9A%84%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[什么是函数节流?为什么要用到函数节流?函数节流可以解决哪写问题? 函数节流 使用场景: (1)对于常见的场景，如网页滚动时，经常会有滚动到哪时做什么样的动画效果，遂要注册onscroll事件，如何减少触发次数，到达优化性能，同时又满足效果要求不卡顿，一个是优化事件内代码，减少代码量，二就是做函数节流。 (2)在前端开发中，有时会为页面绑定resize事件，或者为一个页面元素绑定拖拽事件（其核心就是绑定mousemove），这种事件有一个特点，就是用户不必特地捣乱，他在一个正常的操作中，都有可能在一个短的时间内触发非常多次事件绑定程序。而大家知道，DOM操作时很消耗性能的，这个时候，如果你为这些事件绑定一些操作DOM节点的操作的话，那就会引发大量的计算，在用户看来，页面可能就一时间没有响应，这个页面一下子变卡了变慢了。甚至在IE下，如果你绑定的resize事件进行较多DOM操作，其高频率可能直接就使得浏览器崩溃。原理 定时器，当触发一个事件时，先setTimeout让这个事件延迟一会再执行，如果在这个时间间隔内又触发了事件，那我们就clear掉原来的定时器，再setTimeout一个新的定时器延迟一会执行 123456789function throttle(method, context) &#123; clearTimeout(method, tId); method.tId = setTimeout(function()&#123; method.call(context); &#125;)&#125;window.onresize = function() &#123; throttle(myFunc);&#125; 1234567891011var throttle = function(fn, delay) &#123; var timer = null; return function() &#123; var context = this, args = arguments; clearTimeout(timer); timer = setTimeout(function() &#123; fn.apply(context, args); &#125;, delay); &#125;&#125;window.onresize = throttle(myFunc, 100); 12345678910111213141516171819var throttleV2 = function (fn, delay, mustRunDelay) &#123; var timer = null; var t_start; return function() &#123; var context = this, args = arguments, t_curr = +new Date(); clearTimeout(timer); if(!t_start) &#123; t_start = t_curr; &#125; if(t_curr - t_start &gt;= mustRunDelay) &#123; fn.apply(context, args); &#125; else &#123; timer = setTimeout(function() &#123; fn.apply(context, args); &#125;, delay); &#125; &#125;&#125;window.onresize = throttleV2(myFunc, 50, 100);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js垃圾回收机制]]></title>
    <url>%2F2017%2F08%2F27%2Fjs%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[你了解javascript的垃圾回收机制么? 引用计数此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。 标记清除当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。 垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个怎样都不想认输的🌹]]></title>
    <url>%2F2017%2F08%2F26%2F%E4%B8%8D%E6%83%B3%E5%83%8F%E7%94%9F%E6%B4%BB%E4%BD%8E%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[毕业两个月,在北京已待了一年多,我成长了很多,无论技术,还是心理…现在有点开始明白之前为什么一个要晚上十点下班的公司,当时面试技术过了,但是最后却要了一个男生,(最后没被面试上,那个技术面试官还特意打电话说,不是因为你技术不行,而是我们这儿加班很严重,所以综合考虑招了个男同事,让我继续💪); 连续快一个月了,每天晚上一点睡,现在感觉真的身体快吃不消了,昨天上班头疼的已坚持不住,所有跟老大说了一下,晚上八点就早点回去了,电梯里碰到了清洁工阿姨,阿姨会问,吃饭了么,又加班了么,这个点下班真的是太晚了,回去早点休息…(突然想起我妈对我的唠叨) 本来打算晚上回去就睡,躺在床上,突然想起一个解决今天复杂的数据关系的一个思路,于是爬起来打开电脑开始尝试,看了看时间,晚上9点,心里想着最晚11点一定要睡,可是写代码的过程中又遇到很多不会的问题,于是好奇心促使我弄明白我什么… 就这样过了12点…, 一点的时候,实在太困,匆忙把代码传到git上,倒头就睡… 闹钟响了,实在挣不开眼,想着再睡十分钟,一会洗漱一定不墨迹; 10分钟搞定,出门的时候看着天气不对,又赶紧找了把伞,看了一个,好,衣服没穿反,放心的找了辆小黄,骑着飞速跑起来,不好,这两车骑得有点费劲,算了,还是赶紧走吧,有辆车就不错了,路上很堵,堵到一路上都被自行车骑着走,但是心理还是很庆幸自己今天没有做公交车; 到了一个红绿灯路口,看到指挥交通的大爷,等红灯的时候大爷很热情的跟我聊天,说今天要下大雨,问我有没有带雨伞,(有一次因为胃疼差点晕倒,这位大爷看到了就扶了我一下,还打算送我去医院,说小姑娘一个人在外面要好好照顾自己,当时眼泪真的就下来了,在帝都这样冷漠的城市,有个陌生人能对你这样,突然感觉很温暖) 有时候会想是不是自己老了啊,去年这会刚工作,也是每天很累,因为很多东西要学,记得当时每天晚上看书到两点,周末不加班的时候,也是推了很多’约会’,睡上一上午,然后又开始敲代码… 很累的时候,有时候真的是想放弃,有亲戚跟我打电话,说他们那儿招这种刚毕业的学计算机的,一个月刚开始5000,还给解决住房问题,问我要不要考虑回去,毕竟帝都真的很恐怖;可是我刚毕业技术还有很大的上升空间,还是北京这样的大城市技术发展比较好,更能快速成长, 有时候也会想不如拿着自己的高中教师证回去当老师,或者考个公务员,或者找的对自己好的男的,直接结婚,像很多身边的女朋友一样,然后带孩子…可是那样的生活好像一眼就能望到头,那是我喜欢的生活么? 想起当初自己为什么铁了心的要转行,当时也是能想到以后会遇到很多困难,会很累,找工作的时候,学历就是普通本科,专业又是农业,我只能靠自己过硬的技术来比过自己的竞争者. 我正在为自己想要的生活去奋斗,不想平庸的过一辈子,在外面的时候,不要把自己当成一个女生,因为生活并不会因为你是女生而对你手下留情,所有还是像个汉子一样去努力吧,我相信越努力越幸运]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嘿,使用vue,你注意到了这些了么?]]></title>
    <url>%2F2017%2F08%2F23%2Fvue%E4%B8%AD%E6%A3%80%E6%B5%8B%E4%B8%8D%E5%88%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[使用vue过程中,遇到了一些问题,这里先总结以下两个: 问题一:vue组件之间传递数据,在子组件中我想改变一个从父组件中传过来的值 这是父组件1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;Child :message="message"&gt;&lt;/Child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from './child.vue';export default &#123; data() &#123; return &#123; message: '这是传给子组件的信息', &#125;; &#125;, components: &#123; Child, &#125;,&#125;;&lt;/script&gt; 这是子组件123456789101112131415161718192021&lt;template&gt; &lt;div @click="handleChange"&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; message: &#123; type: String, default: '这是默认信息', &#125;, &#125;, methods: &#123; handleChange() &#123; this.message = '我是子组件修改后的信息'; &#125;, &#125;, &#125;;&lt;/script&gt; 如果你这样写就会报一下错误但是在子组件中，我们不要去修改 prop。如果你必须要修改到这些数据，你可以使用以下方法： 把 prop 赋值给一个局部变量，然后需要修改的话就修改这个局部变量，而不影响 prop1234567891011121314151617181920212223242526&lt;template&gt; &lt;div @click="handleChange"&gt; &#123;&#123;newMessage&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; message: &#123; type: String, default: '这是默认信息', &#125;, &#125;, data() &#123; return &#123; newMessage: this.message, &#125;; &#125;, methods: &#123; handleChange() &#123; this.newMessage = '我是子组件修改后的信息'; &#125;, &#125;, &#125;;&lt;/script&gt; 问题二:vue中检测不到data的变化,我想把给data中的a赋值一个新的对象(添加一个它本身不存在的属性),然而经过尝试发现直接赋值是行不通的,以下是我做的一下尝试12345&lt;template&gt; &lt;div&gt; &#123;&#123;a&#125;&#125; &lt;/div&gt;&lt;/template&gt; 123456789101112131415 data() &#123; return &#123; a: &#123;&#125;, &#125;; &#125;, created() &#123; setTimeout(() =&gt; &#123; this.a.b = 1; &#125;, 1000) &#125;, watch: &#123; a(newVal, oldVal) &#123; console.log(`$&#123;oldVal&#125;现在变成了$&#123;newVal&#125;`); &#125;,&#125;, 上面这样写(给对象a添加一个本来不存在的属性b,并给他赋值)并不会触发watch, vue文档中也明确表示添加到对象上的新属性不会触发更新,所以我们应该新建一个新的对象并将这个心对象的值赋值给原有的对象12345678910111213141516171819export default &#123; data() &#123; return &#123; a: &#123;&#125;, &#125;; &#125;, created() &#123; setTimeout(() =&gt; &#123; this.a = &#123; b: 1, &#125;; &#125;, 500); &#125;, watch: &#123; a(newVal, oldVal) &#123; console.log(`$&#123;oldVal&#125;现在变成了$&#123;newVal&#125;`); &#125;, &#125;,&#125;; 由此给大家拓展一个对象的一些知识tips1: js取值的两种方式的区别123const obj = &#123;abc:"ss",nn:90&#125;;const v1 = obj.abc; // 使用点的方式const v2 = obj["abc"]; // 使用中括号的方式 在实际项目中一般使用.会方便很多,但是key是变量的话就不能使用.,js对象会理解变量为对象的key值, 1const v3 = obj[key]; tips2: 对象深拷贝实现方法 先解释什么是深拷贝和浅拷贝 浅拷贝是对对象地址的复制,并没有开辟新的栈,复制的结果是两个对象指向同一个地址,修改其中一个对象的属性,另一个对象的属性也会改变 深拷贝是开辟新的栈,两个对象对应两个不同的地址,修改一个对象的属性,不会改变另一个对象的属性 最简单的如下(方法一) 1b = JSON.parse( JSON.stringify(a) ) 但是会存在一些问题 无法复制函数 原型链没了，对象就是object，所属的类没了。 使用递归(方法二) 12345678910111213141516171819202122232425262728const obj1 = &#123; name: 'cehsi', age: 13, friends:['sk','ls'],&#125;function deepCopy(o, c) &#123; var c = c || &#123;&#125;; for(const i in o) &#123; if(typeof o[i] === 'object') &#123; // 判断是对象 if(o[i].constructor === Array) &#123; // 数组 c[i] = []; &#125; else &#123; c[i] = &#123;&#125;; &#125; deepCopy(o[i], c[i]); &#125; else &#123; c[i] = o[i]; &#125; &#125; return c;&#125;let obj2 = &#123;name: 'result'&#125;;obj2 = deepCopy(obj1, obj2);console.log(obj2); // &#123; name: 'cehsi', age: 13, friends: [ 'sk', 'ls' ] &#125;obj2.age = 20;console.log(obj2, obj1); // &#123; name: 'cehsi', age: 20, friends: [ 'sk', 'ls' ] &#125; &#123; name: 'cehsi', age: 13, friends: [ 'sk', 'ls' ] &#125; 使用npm install deepcopy tips3: 深对比,方法参考 http://stackoverflow.com/questions/1068834/object-comparison-in-javascript 方法一:Object.toJSON() 1这个方法简单,但是只适用于两个对象属性相同的情况,在没有方法和DOM节点的情况下，您可以使用简单的JSON样式对象： 123456789101112131415const obj1 = &#123; a: 1, b: 2,&#125;const obj2 = &#123; a: 1, b: 2,&#125;const obj3 = &#123; b: 2, a: 1,&#125;console.log(JSON.stringify(obj1) === JSON.stringify(obj2)); // trueconsole.log(JSON.stringify(obj1) === JSON.stringify(obj3)); // false 方法二: 深度比较两个对象 1比较对象而不挖掘原型，然后递归地比较属性的投影，还可以比较构造函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113function deepCompare(x, y) &#123; var i, l, leftChain, rightChain; function compare2Objects(x, y) &#123; var p; // remember that NaN === NaN returns false // and isNaN(undefined) returns true if (isNaN(x) &amp;&amp; isNaN(y) &amp;&amp; typeof x === 'number' &amp;&amp; typeof y === 'number') &#123; return true; &#125; // Compare primitives and functions. // Check if both arguments link to the same object. // Especially useful on the step where we compare prototypes if (x === y) &#123; return true; &#125; // Works in case when functions are created in constructor. // Comparing dates is a common scenario. Another built-ins? // We can even handle functions passed across iframes if ((typeof x === 'function' &amp;&amp; typeof y === 'function') || (x instanceof Date &amp;&amp; y instanceof Date) || (x instanceof RegExp &amp;&amp; y instanceof RegExp) || (x instanceof String &amp;&amp; y instanceof String) || (x instanceof Number &amp;&amp; y instanceof Number)) &#123; return x.toString() === y.toString(); &#125; // At last checking prototypes as good as we can if (!(x instanceof Object &amp;&amp; y instanceof Object)) &#123; return false; &#125; if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) &#123; return false; &#125; if (x.constructor !== y.constructor) &#123; return false; &#125; if (x.prototype !== y.prototype) &#123; return false; &#125; // Check for infinitive linking loops if (leftChain.indexOf(x) &gt; -1 || rightChain.indexOf(y) &gt; -1) &#123; return false; &#125; // Quick checking of one object being a subset of another. // todo: cache the structure of arguments[0] for performance for (p in y) &#123; if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) &#123; return false; &#125; else if (typeof y[p] !== typeof x[p]) &#123; return false; &#125; &#125; for (p in x) &#123; if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) &#123; return false; &#125; else if (typeof y[p] !== typeof x[p]) &#123; return false; &#125; switch (typeof(x[p])) &#123; case 'object': case 'function': leftChain.push(x); rightChain.push(y); if (!compare2Objects(x[p], y[p])) &#123; return false; &#125; leftChain.pop(); rightChain.pop(); break; default: if (x[p] !== y[p]) &#123; return false; &#125; break; &#125; &#125; return true; &#125; if (arguments.length &lt; 1) &#123; return true; //Die silently? Don't know how to handle such case, please help... // throw "Need two or more arguments to compare"; &#125; for (i = 1, l = arguments.length; i &lt; l; i++) &#123; leftChain = []; //Todo: this can be cached rightChain = []; if (!compare2Objects(arguments[0], arguments[i])) &#123; return false; &#125; &#125; return true;&#125; 已知问题（他们的优先级很低，可能你永远不会注意到） 具有不同原型结构但相同投影的物体 函数可能具有相同的文本，但是指的是不同的闭包原型]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[揭开vue神秘面纱]]></title>
    <url>%2F2017%2F08%2F20%2F%E6%8F%AD%E5%BC%80vue%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%2F</url>
    <content type="text"><![CDATA[带你一步一步走进vue About源码aboutmegithubblog 实现过程,直接上代码1,实现简单的v-model的绑定1234567891011121314151617&lt;body&gt; &lt;input type="text" id="input" v-model="a"/&gt; &lt;p&gt;可以打开控制台,然后输入vm.查看view到model的绑定;然后改变input的值,再次在控制台输出vm.查看model到view的绑定&lt;/p&gt; &lt;!-- &lt;script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"&gt;&lt;/script&gt; --&gt; &lt;script&gt; window.vm = new Vue(&#123; data: &#123; b: 10000, a: 1 &#125;, el: '#input' &#125;); setInterval(() =&gt; &#123; vm.a++; &#125;, 1000); &lt;/script&gt;&lt;/body&gt; 123456789101112131415161718192021222324252627282930function Vue(data) &#123; const input = document.querySelector(data.el); let model = input.getAttribute('v-model'); if(!data.data) &#123; console.warn(`你没有定义data`); return; &#125; if(model &amp;&amp; data.data.hasOwnProperty(model))&#123; // 实现model到view的绑定 input.value = data.data[model]; Object.defineProperty(this, model, &#123; configurable: true, enumerable: true, get: function() &#123; return data.data[model]; &#125;, set: function(newVal) &#123; input.value = data.data[model] = newVal; &#125;, &#125;) // 实现view到model的绑定 input.addEventListener("input", () =&gt; &#123; this[model] = input.value; &#125;); &#125; else &#123; console.warn(`你没有定义$&#123;model&#125;属性`); return; &#125;&#125; 把一个普通 JavaScript 对象传给 Vue 实例的 data选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。 给input添加oninput事件实现view到model的绑定,即在input中输入一个值,vm.a也会跟着发生变化 2,实现多个v-model的绑定123456789101112131415161718192021&lt;body&gt; &lt;div id="form"&gt; &lt;input type="text" v-model="a" /&gt; &lt;br /&gt; &lt;input type="text" v-model="b" /&gt; &lt;div&gt; &lt;input type="text" v-model="c" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- &lt;script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"&gt;&lt;/script&gt; --&gt; &lt;script&gt; window.vm = new Vue(&#123; data: &#123; a: 0, b: 100, c: 2, &#125;, el: '#form' &#125;); &lt;/script&gt;&lt;/body&gt; 123456789101112131415161718192021function Vue(data) &#123; const input = document.querySelectorAll('input'); for (const item of input) &#123; let model = item.getAttribute('v-model'); item.value = data.data[model]; Object.defineProperty(this, model, &#123; configurable: true, enumerable: true, get: function () &#123; return data.data[model]; &#125;, set: function (newVal) &#123; item.value = data.data[model] = newVal; &#125;, &#125;) item.addEventListener("input", () =&gt; &#123; this[model] = item.value; &#125;); &#125;&#125; 实现原理个实现一个v-model差不多 3,实现模板的绑定 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div id="form"&gt; &lt;input type="text" v-model="a" /&gt; &lt;input type="text" v-model="a" /&gt; &lt;p&gt;&#123;&#123; a &#125;&#125;&lt;/p&gt; &lt;br /&gt; &lt;input type="text" v-model="b" /&gt; &#123;&#123; b &#125;&#125; &lt;div&gt; &lt;input type="text" v-model="c" /&gt; &lt;p&gt;&#123;&#123; c &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; c &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- &lt;script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"&gt;&lt;/script&gt; --&gt; &lt;script&gt; window.vm = new Vue(&#123; data: &#123; a: 0, b: 100, c: 2, &#125;, el: '#form' &#125;); console.log(vm); &lt;/script&gt;&lt;/body&gt; 用正则匹配到html中的模板字符串,然后将相应的部分替换成变量 匹配html中多个模板,必须先了解dom的结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function Vue(data) &#123; const input = document.querySelectorAll('input'); for (const item of input) &#123; let model = item.getAttribute('v-model'); item.value = data.data[model]; Object.defineProperty(this, model, &#123; configurable: true, enumerable: true, get: function () &#123; return data.data[model]; &#125;, set: function (newVal) &#123; item.value = data.data[model] = newVal; &#125;, &#125;) item.addEventListener("input", () =&gt; &#123; this[model] = item.value; &#125;); &#125; const pss = document.querySelector(data.el).childNodes; let ps = []; let arr = []; function getText(value) &#123; for (var i = 0, len = value.length; i &lt; len; i++) &#123; if (value[i].nodeType === 1) &#123; getText(value[i].childNodes); &#125; else if (value[i].nodeType === 3) &#123; ps.push(value[i]); &#125; &#125; &#125; getText(pss); const reg = /&#123;&#123;(.*)&#125;&#125;/; ps.forEach((i) =&gt; &#123; if (reg.test(i.nodeValue)) &#123; arr.push(i); &#125; &#125;); console.log(arr); for (const p of arr) &#123; let $p = reg.exec(p.nodeValue)[0].slice(2, p.nodeValue.length - 2).replace(/\s/g, ''); p.nodeValue = data.data[$p]; Object.defineProperty(this, $p, &#123; configurable: true, enumerable: true, get: function () &#123; return data.data[$p]; &#125;, set: function (newVal) &#123; p.nodeValue = data.data[$p] = newVal; &#125;, &#125;) &#125;&#125;// 错在多次赋值被覆盖的错误,所以思路应该变为找到所有绑定a, b, c的值,然后统一赋值 4,实现v-bind,v-on的绑定12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;body&gt; &lt;div id="form"&gt; &lt;h4&gt;这是测试v-model的效果&lt;/h4&gt; &lt;input type="text" v-model="a" /&gt; &lt;input type="text" v-model="a" /&gt; &lt;hr&gt; &lt;h4&gt;这是测试&#123;&#123;&#125;&#125;的效果&lt;/h4&gt; &lt;div&gt;&#123;&#123; a &#125;&#125;&lt;/div&gt; &lt;p&gt;&#123;&#123; a &#125;&#125;&lt;/p&gt; &#123;&#123; a &#125;&#125;&#123;&#123; b &#125;&#125; &lt;br /&gt; &lt;input type="text" v-model="b" /&gt; &lt;p&gt;&#123;&#123; b &#125;&#125;&lt;/p&gt; &lt;div&gt; &lt;input type="text" v-model="c" /&gt; &lt;p&gt;&#123;&#123; c &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;hr&gt; &lt;h4&gt;这是测试v-bind和v-on的效果&lt;/h4&gt; &lt;img v-bind:src="src" v-bind:width="width1" :height="height" v-on:click="log" /&gt; &lt;p&gt;打开控制台,点击img,查看v-on的绑定效果&lt;/p&gt; &lt;/div&gt; &lt;!-- &lt;script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"&gt;&lt;/script&gt; --&gt; &lt;script&gt; window.obj = &#123; a: 0, b: 100, c: '这是测试', src: "http://cdn.suisuijiang.com/message_1492395396308.png?imageView2/2/w/40/h/40", width1: 100, height: 100, &#125;; window.vm = new Vue(&#123; el: '#form', data: obj, methods: &#123; log: function() &#123; console.log('你点击了图片'); console.log(`当前c的值为 $&#123;this.c&#125;`); &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; /** * 解析dom指令 * @param {*} $dom 根节点 * @param {*} instructs 解析结果 */ function handleInstruct($dom, instructs = {}) { function addInstruct(model, type, $node) { if (instructs[model]) { if (instructs[model][type]) { instructs[model][type].push($node); } else { instructs[model][type] = [$node]; } } else { instructs[model] = { [type]: [$node] }; } } if ($dom.attributes) { for (const attr of $dom.attributes) { if (attr.name === 'v-model') { const model = $dom.getAttribute('v-model'); addInstruct(model, 'model', $dom); } else if (/^(v-bind|:)/.test(attr.nodeName)) { const parseResult = attr.nodeName.match(/^(?:v-bind)?:([a-zA-Z_$][a-zA-Z0-9_$]*)/); if (parseResult &amp;&amp; parseResult[1]) { addInstruct(attr.nodeValue.trim(), 'bind', { $dom, attr: parseResult[1] }); } } else if (/^(v-on|@)/.test(attr.name)) { const parseResult = attr.name.match(/^(?:v-on:|@)?([a-zA-Z_$][a-zA-Z0-9_$]*)/); if (parseResult &amp;&amp; parseResult[1]) { addInstruct(attr.nodeValue.trim(), 'on', { $dom, event: parseResult[1] }); } } } } if ($dom.childNodes) { for (const $child of $dom.childNodes) { switch ($child.nodeType) { // ELEMENT_NODE case 1: { handleInstruct($child, instructs); break; } // TEXT_NODE case 3: { const parseResult = $child.data.match(/{{[ ]*([a-zA-Z_$][a-zA-Z0-9_$]*)[ ]*}}/g); if (parseResult) { parseResult.forEach(x =&gt; { const model = x.match(/[a-zA-Z_$][a-zA-Z0-9_$]*/); if (model) { addInstruct(model, 'expression', { $dom: $child, exp: $child.data }); } }); } break; } default: break; } } } return instructs; } function updateDom(vm, instructs, model, shouldRegisterEvent = false) { // 实现v-model的绑定 if (instructs[model].model) { for (const $el of instructs[model].model) { $el.value = vm[model]; if (shouldRegisterEvent) { $el.oninput = () =&gt; { this[model] = $el.value; }; } } } // 实现{{}}的绑定 if (instructs[model].expression) { for (let { $dom, exp } of instructs[model].expression) { const parseResult = exp.match(/{{[ ]*([a-zA-Z_$][a-zA-Z0-9_$]*)[ ]*}}/g); if (parseResult) { parseResult.forEach(x =&gt; { const m = x.match(/[a-zA-Z_$][a-zA-Z0-9_$]*/); if (m) { exp = exp.replace(new RegExp(`{{[ ]*${m[0]}[ ]*}}`), vm[m[0]]); } }); } $dom.textContent = exp; } } // 实现v-bind的绑定 if (instructs[model].bind) { for (const {$dom, attr} of instructs[model].bind) { $dom.setAttribute(attr, vm[model]); } } } function Vue(params) { const $dom = document.querySelector(params.el); if (!$dom) { console.error(`dom "${params.el}" not exist`); return; } const vm = {}; const instructs = handleInstruct($dom); // console.log(instructs); for (const model in instructs) { if (model &amp;&amp; params.data &amp;&amp; Object.prototype.hasOwnProperty.call(params.data, model)) { vm[model] = params.data[model]; Object.defineProperty(this, model, { get: function() { return vm[model]; }, set: function(newValue) { vm[model] = newValue; updateDom(vm, instructs, model); } }); updateDom.call(this, vm, instructs, model, true); } // 实现v-on的绑定 if (instructs[model].on) { for (const { $dom, event } of instructs[model].on) { $dom.addEventListener(event, params.methods[model].bind(this)); } } } } window.Vue = Vue;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小记-iweb峰会]]></title>
    <url>%2F2017%2F08%2F12%2F2017-08-11-%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[看到了好多大佬,而且很幸运的中奖了,一个金三角的耳机~今天早上起来的时候下着雨,本来以为不会有那么多人了,可是到的时候会议室真的是坐满了人;上午将的都是h5游戏的发展,自从2014年7月22日起，’围住神经猫’这款小游戏在微信朋友圈疯传开来之后,h5小游戏就开始非常火,看来js还是很强大的.]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for in vs for of]]></title>
    <url>%2F2017%2F07%2F03%2F2017-07-03-for-in-vs-for-of%2F</url>
    <content type="text"><![CDATA[for in 和 for of 的区别 for in 更适合遍历对象，不要使用for in 遍历数组 for in 遍历的是数组的索引(即键名)，而for of 遍历的是数组元素值 12345678910111213141516171819202122232425262728293031323334Object.prototype.methods = function () &#123; console.log(this);&#125;;var myObject = &#123; a: 1, b: 2, c: 3,&#125;;使用for in 遍历对象的键名 for (var key in myObject) &#123; console.log(key); &#125; a b c methodsfor in 可以遍历到myObject的原型方法methods，如果不想遍历原型方法和属性的话.可以用hasOwnPropery方法可以判断某属性是否是该对象的实例属性 for (var key in myObject) &#123; if(myObject.hasOwnProperty(key))&#123; console.log(key); &#125; &#125; a b c console.log(Object.keys(myObject)); [ 'a', 'b', 'c' ]Object.keys(myObject).forEach(function(key, index)&#123; console.log(key, myObject[key]);&#125;) a 1 b 2 c 3 同样可以通过ES5的Object.keys(myObject)获取对象的实例属性组成的数组，不包括原型方法和属性。 for of 用来遍历数组的值]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中scroll的用法]]></title>
    <url>%2F2017%2F06%2F23%2F2017-06-23-vue-scroll%2F</url>
    <content type="text"><![CDATA[12345678910111213141516data () &#123; return &#123; scrolled: false &#125;;&#125;,methods: &#123; handleScroll () &#123; this.scrolled = window.scrollY &gt; 0; &#125;&#125;,created () &#123; window.addEventListener('scroll', this.handleScroll);&#125;,destroyed () &#123; window.removeEventListener('scroll', this.handleScroll);&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程之尾调用]]></title>
    <url>%2F2017%2F06%2F01%2F2017-06-01-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%B0%BE%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[尾调用，就是在函数的最后一步调用另一个函数123function foo(x) &#123; return g(x);&#125; 尾调用不一定出现在函数尾部，只要是最后一步操作就行 123456function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 函数m和n都属于尾调用，他们都是函数的最后一步操作 尾调用优化函数调用会在内存形成一个’调用记录‘，保存调用位置和内部变量等信息，如果在A函数中调用B函数，在A函数的调用记录上还会形成一个B的调用记录，等到B函数运行结束后，把结果返回到A，B的调用记录才会消失。如果函数B内部还调用C函数，那就是还有一个C的调用记录栈，以此类推，所有的调用记录，就会形成一个’调用栈‘。 尾调用在于它特殊的调用位置。由于是函数最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置和内部变量都不会再用到了。 ’尾调用优化‘，只调用内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-redux]]></title>
    <url>%2F2017%2F05%2F24%2F2017-05-24-react-redux%2F</url>
    <content type="text"><![CDATA[reduxredux的三个概念: action reducer store action: 一个包含type的object, 通常把一个返回action对象的函数称为action函数, 直接简称为action 1234567function action(data) &#123; return &#123; type: 'Action1', data, &#125;;&#125; reducer: 一个根据action type来更新数据的函数 123456789101112131415function reducer(state = &#123; data: 1 &#125;, action) &#123; switch (action.type) &#123; case 'action1': &#123; const newState = JSON.parse(JSON.stringify(state)); return newState; &#125; case 'action2': &#123; const newState = JSON.parse(JSON.stringify(state)); return newState; &#125; default: &#123; return state; &#125; &#125;&#125; store: 使用createStore从reducer函数创建的数据对象, 包含getState和dispatch方法 1234567import &#123; createStore &#125; from 'redux';let store = createStore(reducer);console.log(store.getState())store.dispatch(action(0))console.log(store.getState()) 注意! 更新数据需要dispatch对应的action react-redux用于将redux于react结合 Provider: 顶层组件, 注入store对象 12345678import &#123; Provider &#125; from 'react-redux';ReactDom.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('app'),); connect: 工具函数, 参数一为函数, 该函数接收state, 返回一个对象, 对象包含一系列数据. 参数二为函数, 该函数接收dispatch, 返回一个对象, 对象包含一系列方法123456789101112131415161718192021222324252627import &#123; connect &#125; from 'react-redux'; class App extends Component &#123; componentDidMount() &#123; this.props.dispatch(&#123; type: 'action1', data: 1, &#125;); &#125; render() &#123; // this.props.func1(); // this.props.func2(); return ( &lt;div&gt; &lt;/div &gt; ); &#125;&#125;export default connect( state =&gt; (&#123; data: state.data, obj: state.obj, &#125;), dispatch =&gt; (&#123; dispatch &#125;),)(App); immutable.js特殊的object(MAP)/array(LIST) 更新数据: set setIn update updateIn 读取数据: get getIn 可以直接比较(深层比较) 创建(fromJS), 还原(toJS) 123456789101112131415上述的reducer可以用下面的代码优化function reducer(state = immutable.fromJS(&#123; data: 1, obj: &#123; aa: 1 &#125; &#125;), action) &#123; switch (action.type) &#123; case 'action1': &#123; return state.set('data', action.data * 10); &#125; case 'action2': &#123; return state.setIn(['obj', 'aa'], action.data); &#125; default: &#123; return state; &#125; &#125;&#125; 优点 无需深复制, 更新数据自动返回一个新对象 适合与react shouldComponentUpdate结合来优化性能 pure-render-decorator自动创建shouldComponentUpdate的工具, 需要配置babel decorator特性才能使用]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue全家桶+crawler+koa2 实现阴阳师小助手]]></title>
    <url>%2F2017%2F05%2F20%2F2017-5-20-vue%E5%85%A8%E5%AE%B6%E6%A1%B6-crawler-koa2-%E5%AE%9E%E7%8E%B0%E9%98%B4%E9%98%B3%E5%B8%88%E5%B0%8F%E5%8A%A9%E6%89%8B%2F</url>
    <content type="text"><![CDATA[最近一直在玩阴阳师，看了好多小助手，觉得太复杂了，还得登录什么的，想着自己写一个简单的小助手，只要输入要搜索的式神，我想知道的关于这个式神的数据就能显示出来。只是第一版，前端用vue全家桶实现的，很适合刚开始接触vue的，后端用node实现的，如果有更好的建议或者想一起合作写个更好用点的，欢迎联系 作者。 yys-fe(阴阳师小助手前端) A Vue.js project github项目链接 阴阳师小助手后端实现 nodejs + crawler + koa2 + mongoose 效果图 基本- 构建工具：webpack； - 语言：Es6； - 代码规范：eslint - 应用：vue， vuex（数据管理架构）， vue-router（路由）， mint-ui（ul组件）， vue-axios（vue做的ajax请求） 目录结构1234567891011121314151617|-- [build] //构建服务和webpack配置|-- [config] //项目不同环境的配置|-- [dist] //文件服务器根目录 |-- [node_modules] //项目依赖|-- [src] //源码| |-- [assets] //资源文件| |-- [components] //项目模块文件夹| |-- [store] //存储数据| | |-- index.js //vuex store 定义| |-- App.vue //主页面 | |-- main.js //webpack预编译入口| |-- [router] //全局路由定义|-- .babelrc //babel配置|-- .eslintrc.js //eslint rule 定义|-- index.html //项目入口文件|-- package.json //项目配置文件|-- README.md //关于启动项目的命令和含义 已经完成的模块 式神搜索页面(支持模糊搜索) 式神搜索结果页面 式神列表页面 式神详细信息页面 [X] 推荐御魂 [X] 推荐搭配 [X] 式神点评 待完成与优化 搜索功能添加历史搜索和热门搜索 式神攻略 式神视频 页面样式的优化 Build Setup``` bash install dependenciesnpm install serve with hot reload at localhost:8080npm run dev build for production with minificationnpm run build 关于用vue时遇到的坑，记录在我的博客,希望可以对大家有用目前小编在学react，所以用react也写了一版,所以刚开始接触react的童鞋也可以看一下，想着第二版的ui设计的好看一点儿，功能再多一点儿，期待更多的建议。 Aboutaboutmegithubblog]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2017%2F05%2F03%2F2017-05-03-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。 排序算法 冒泡算法 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 12345678910111213function bubbleSort(arr) &#123; for(let i = 0; i &lt; arr.length; i++) &#123; for (var j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125;console.log(bubbleSort([1,23,4,3])); 快速排序,通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 1234567891011121314151617function quickSort(arr) &#123; if(arr.length &lt;= 1) &#123; return arr; &#125; let leftArr = []; let rightArr = []; let q = arr[0]; for(let i = 1; i&lt;arr.length;i++) &#123; if(arr[i] &gt; q) &#123; rightArr.push(arr[i]); &#125; else &#123; leftArr.push(arr[i]); &#125; &#125; return [].concat(quickSort(leftArr),[q],quickSort(rightArr));&#125;console.log(quickSort([1,23,4,3]));]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端拿高薪必看面试题]]></title>
    <url>%2F2017%2F05%2F02%2F2017-05-02-js%E7%BB%8F%E5%85%B8%E7%AC%94%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[面试之前都会从网上找很多面试题来看,尤其是看到经典面试题,及必会的面试题,都是好好的看上几遍(其实更多的时候都是在背),可是总感觉面试之前看题作用并不大,因为你不理解的问题,还是会不理解,面试管随便一问,就不行了.其实面试几次后就会发现,经常问的问题也就那几个,比如,闭包,原型链,this,等.刚开始的时候真的是理解不了,然后就看书,强烈推荐《javascript高级程序设计(第三版)》以及《你不知道的javascript系列》,在实际项目中遇到坑的时候,就反复看,看的时候很难受,但是当真正理解了之后,就会恍然大悟,所以功夫还是下在平时,临时抱佛脚真的没啥用~ 以下是我总结的面试题中常问到的,很多都是我亲身经历的面试中遇到的一些问题,刚开始遇到的时候也不是太清楚,面试完之后就深入的学习了一下相关的知识😜 1,考察this 1234567891011121314var length = 10;function fn() &#123; console.log(this.length);&#125;var obj = &#123; length: 5, method: function(fn) &#123; fn(); arguments[0](); &#125;&#125;;obj.method(fn, 1); 10 ，2 第一次输出10应该没有问题。我们知道取对象属于除了点操作符还可以用中括号，所以第二次执行时相当于arguments调用方法，this指向arguments，而这里传了两个参数，故输出arguments长度为2。 123456789101112131415var length = 10;function fn() &#123; console.log(this.length);&#125;var obj = &#123; length: 5, method: function(fn) &#123; fn(); const fun = arguments[0]; fun()； &#125;&#125;;obj.method(fn, 1); 10 102,var和函数的提前声明 12345678function fn(a) &#123; console.log(a); var a = 2; function a() &#123;&#125; console.log(a); &#125;fn(1); function a() {} 2 var和function是会提前声明的.而且function是优先于var声明的(如果同时存在的话),所以刚开始输出的就是一个funciton,接着往下执行a进行重新赋值了,故第二次输出的是2； 3，局部变量和全局变量1234567891011121314var f = true;if (f === true) &#123; var a = 10;&#125;function fn() &#123; var b = 20; c = 30;&#125;fn();console.log(a);console.log(b);console.log(c); 输出 10 报错 30 这是个我犯了很久的错误，很长一段时间我都以为{…}内的新声明的变量是局部变量，后来我才发现function内的新声明的变量才是局部变量，而没有用var声明的变量在哪里都是全局变量。再次提醒切记只有function(){}内新声明的才能是局部变量，while{…}、if{…}、for(..) 之内的都是全局变量（除非本身包含在function内）。 4，变量隐式声明1234if( 'a' in window) &#123; var a = 10;&#125;console.log(a); 10 funciton和var会提前声明,而其实{…}内的变量也会提前声明，于是代码还没执行前a已经被声明了。所以 ‘a’ in window会返回true,a被赋值 5，给基本类型数据添加属性，不报错，但取值时是undefined1234567var a = 10;a.pro = 10;console.log(a.pro + a);var s = 'hello';s.pro = 'world';console.log(s.pro + s); NaN undefinedhello 给基本类型数据加属性不报错，但是引用的话返回undefined,10+undefined返回NaN,而undefined和string相加时转变成了字符串 6，函数声明优先于变量声明123console.log(typeof fn);function fn() &#123;&#125;;var fn; function 因为函数声明优于变量声明。我们知道在代码逐行执行前，函数声明和变量声明会提前进行，而函数声明又会优于变量声明，这里的优于可以理解为晚于变量声明后，如果函数名和变量名相同，函数声明就能覆盖变量声明。所以以上代码将函数声明和变量声明调换顺序还是一样结果。 7,判断一个字符串中出现次数最多的字符，并统计次数1234567891011121314151617181920var s = 'aaabbbcccaaabbbaaa';var obj = &#123;&#125;;var letter;var maxn = -1;for (let i = 0; i&lt; s.length; i++) &#123; if(obj[s[i]]) &#123; obj[s[i]] ++; if(obj[s[i]] &gt; maxn) &#123; maxn = obj[s[i]]; letter = s[i]; &#125; &#125; else &#123; obj[s[i]] = 1; if(obj[s[i]] &gt; maxn) &#123; maxn = obj[s[i]]; letter = s[i]; &#125; &#125; &#125;console.log(`$&#123;letter&#125;:$&#123;maxn&#125;`); 正则12345678910var s = 'aaabbbcccaaabbbaaa';var a = s.split('');a.sort();s = a.join('');var pattern = /(\w)\1*/g;var ans = s.match(pattern);ans.sort(function(a, b) &#123; return a.length &lt; b.length;&#125;)console.log(ans[0][0] + ':' + ans[0].length); 8， 经典闭包123456789101112131415161718192021222324252627282930&lt;!--html--&gt;&lt;ul&gt; &lt;li&gt;这是第1个&lt;/li&gt; &lt;li&gt;这是第2个&lt;/li&gt; &lt;li&gt;这是第3个&lt;/li&gt; &lt;li&gt;这是第4个&lt;/li&gt;&lt;/ul&gt;&lt;!--js--&gt;一：for(var i = 0; i &lt; lis.length; i++) &#123; lis[i].index = i; lis[i].onclick = function() &#123; alert(this.index); &#125;;&#125;二:for(var i = 0; i &lt; lis.length; i++) &#123; (function(i) &#123; lis[i].onclick = function() &#123; alert(i); &#125;; &#125;)(i); &#125;三：for(let i = 0; i &lt; lis.length; i++) &#123; lis[i].onclick = function() &#123; alert(i); &#125;;&#125; 从0开始隔10s按顺序出现’第一次出现’,’第二次出现’,’第三次出现‘123456789101112131415const datas = ['1', '2', '3'];let timer = null;for (let i = 0; i &lt; datas.length; i++) &#123; // const index = i; if (timer) &#123; clearTimeout(timer); let timer = setTimeout(function () &#123; console.log(datas[i]); &#125;, 10000 * i) &#125; else &#123; let timer = setTimeout(function () &#123; console.log(datas[i]); &#125;, 10000 * i) &#125;&#125;; 9，请编写一个JavaScript函数 parseQueryString，它的用途是把URL参数解析为一个对象，如： var url = “http://witmax.cn/index.php?key0=0&amp;key1=1&amp;key2=2″1234567891011121314function parseQueryString(url) &#123; var obj = &#123;&#125;; var a = url.split('?'); if(a.length === 1) return obj; var b = a[1].split('&amp;'); for(var i = 0, length = b.length; i &lt; length; i++) &#123; var c = b[i].split('='); obj[c[0]] = c[1]; &#125; return obj;&#125;var url = 'http://witmax.cn/index.php?key0=0&amp;key1=1&amp;key2=2';var obj = parseQueryString(url);console.log(obj.key0, obj.key1, obj.key2); // 0 1 2 10,this1234567891011var baz=3;var bazz=&#123; baz: 2, getbaz: function() &#123; return this.baz &#125;&#125;console.log(bazz.getbaz())var g=bazz.getbaz;console.log(g());第一个输出2，第二个输出3,函数作为对象本身属性调用的时候this指向对象，作为普通函数调用的时候就指向全局了 11，数组方法 数组排序:写一个js函数,将数组对象按照一定的顺序进行排序，且可通过参数决定升降序 123456789101112131415161718192021222324const list = [ &#123; "name": "first", "index": 1, &#125;, &#123; "name": "second", "index": 2, &#125;, &#123; "name": "third", "index": 3, &#125;, &#123; "name": "fourth", "index": 4, &#125;,]function compare(property)&#123; return function(a,b)&#123; return a[property] - a[property]; &#125;&#125;console.log(list.sort(compare('index'))) 12,求一个字符串的字节长度12345678910111213function GetBytes(str)&#123; var len = str.length; var bytes = len; for(var i=0; i&lt;len; i++)&#123; if (str.charCodeAt(i) &gt; 255) bytes++; &#125; return bytes; &#125;alert(GetBytes("你好,as"));str = 'hello world';console.log(str.charCodeAt(0)); // 104, 返回指定索引处字符的 Unicode 数值,大于255为中文console.log(str.charAt(0)); // h, 返回指定位置的字符, 13 jsonp原理及过程 利用标签没有跨域限制的“漏洞”（历史遗迹啊）来达到与第三方通讯的目的。 当需要通讯时，本站脚本创建一个元素，地址指向第三方的API网址，形如 并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如：callback({“name”:”hax”,”gender”:”Male”})这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。 14, link和@import区别 link属于html标签，而@import是css提供的。 页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。 link是html标签，因此没有兼容性，而@import只有IE5以上才能识别。 link方式样式的权重高于@import的 15,一个页面从输入url到页面加载显示完成,这个过程都发生了什么? 1,浏览器开启一个线程来处理这个请求 2,查找浏览器缓存(浏览器缓存-系统缓存-路由器缓存) 3,DNS解析,查找该域名对应的IP地址,重定向(301), 4,向真实IP地址服务器发出tcp连接,tcp三次握手 5,握手成功后,进行http协议会话,浏览器发送报头 6,进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器; 7,进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理; 8,处理结束回馈报头，将数据返回至浏览器; 9,浏览器开始下载html文档(响应报头，状态码200)，同时设置缓存; 10,之后浏览器对整个 HTML 结构进行解析，形成 DOM 树；与此同时，它还需要对相应的 CSS 文件进行解析，形成 CSS 树（CSSOM）。 11,得到绘制树之后，需要计算每个结点在页面中的位置，这一个过程称为layout 浏览器这边做的工作大致分为以下几步：加载：根据请求的URL进行域名解析，向服务器发起请求，接收文件（HTML、JS、CSS、图象等）。解析：对加载到的资源（HTML、JS、CSS等）进行语法解析，建议相应的内部数据结构（比如HTML的DOM树，JS的（对象）属性表，CSS的样式规则等等） 16,TCP传输的三次握手四次挥手策略 三次握手 SYN和ACK 发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。 四次挥手 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。17, new操作符到底干了什么?深入了解 1,创建一个空对象,而且this变量引用该对象,同时还继承了该函数的原型. 2,属性和方法被加入到this引用的对象中, 3,新创建的对象由this所引用,而且最后隐式的返回this18, null和undefined的区别? undefined (1)变量被声明了,但是没有赋值,就等于undefined (2)调用函数时,应该提供的参数没有提供,该参数等于undefined (3)对象没有赋值的属性,该属性的值为undefined (4)函数没有返回值时,默认返回undefinednull (1)作为函数的参数,表示该函数的参数不是对象 (2)作为对象原型链的终点 19, js的基本数据类型Number,String,Boolean,Null, Undefined,Object,Symbol 20,DOM怎样添加,移除,复制,和创建节点12345678910111213// 创建新节点createDocumentFragment(); // 创建一个DOM片段createElement(); // 创建一个具体的元素createTextNode(); // 创建一个文本节点//添加,移除,替换appendChild()removeChild()replaceChild()insertBefore() // 在已有的子节点前插入一个新的子节点// 查找getElementByTagName() // 通过标签名称getElementByName() // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)getElementById() // 通过元素ID,唯一性 参考总结这10道javaScript笔试题你都会么正则2016年十家公司面试小记浅谈javascript的函数节流面试题1面试题2面试题3html与css道阻且长啊TAT(前端面试总结),17年春招面试总结 Aboutaboutmegithubblog]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于斐波那契数列]]></title>
    <url>%2F2017%2F04%2F09%2F2017-04-09-%E5%85%B3%E4%BA%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[用js实现斐波那契数列首先介绍一下，斐波那契数列(Fibonacci sequence)又称黄金分割数列，斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=1，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用， 斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368…….. 这个数列从第3项开始，每一项都等于前两项之和。 实现方法一 1234567891011121314function fib(n) &#123; if(n === 0) &#123; return 0; &#125; else if(n ===1) &#123; return 1; &#125; else &#123; return fib(n-1)+fib(n-2); &#125;&#125;以上的发法是能想到的最直观的实现，现在我们测试一下他的运行结果。fib(1);fib(10)fib(50);运行发现n=1时，会快速输出1，n=10,时，运行速度稍慢，但是当n=10时，运行就非常慢，原因是什么呢，因为n=50时，要进行差不多50次的函数调用，每次调用，都会重新走if的那三个判断条件，而且每次都是从最开始开始计算，当n越大时，性能越差，所以有没有更好的方法来实现它呢？ 实现方法二1234567891011121314151617function fib(n) &#123; if(n === 0) &#123; return 0; &#125; else if(n ===1) &#123; return 1; &#125; else &#123; let a = 0, b = 1; let current = null; for(let i = 2; i &lt;= n; i++) &#123; current = b + a; a = b; b = current; &#125; return current; &#125;&#125;方法二与方法一不同之处在于，最后一个判断加入了一个for循环，current = b + a;当前享等于前两项的和，a = b;把前一项的值赋给a(第前两项)，b = current;把当前值赋给前b(第前一项)，这样当n&gt;1时，只需要在第三个判断走一个循环可以，而不需要一直调用函数，这样做比方法一性能上优化了很多，但是还有没有更好的方法呢? 实现方法三1234567891011121314151617181920212223var cache = &#123; 0: 0, 1: 1&#125;;function fib(n) &#123; return typeof cache[n] === 'number' ? cache[n] : cache[n] = fib(n - 1) + fib(n - 2);&#125;该方法的实现利用了缓存，这样每次计算的时候，都会把计算出的值存放到cache这个缓存中，等下次传入较大的n时，如果缓存中有需要的值，则直接用缓存中的值，这种方法大大提高了函数的性能。还存在一个问题,fib(10000) = Infinity;这有是为什么呢，我们可以从js中数值的取值范围考虑，如何知道js中数值的范围呢， console.log(Number.MAX_VALUE, Number.MIN_VALUE); //取得最大和最小的数console.log(Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);取得最大和最小的整数1.7976931348623157e+308 5e-3249007199254740991 -9007199254740991console.log(fib(400));console.log(fib(500));1.760236806450138e+831.394232245616977e+104n 在大于500的时候差不多已超出范围 如果有更好的方法，欢迎指正]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
